<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ballerina By Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="rust">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'rust'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="index.html">Ballerina by Example</a></li><li><a href="hello-world/hello-world.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="hello-world/hello-world.html"><strong>1.1.</strong> Hello World</a></li><li><a href="hello-world-parallel/hello-world-parallel.html"><strong>1.2.</strong> Hello World Parallel</a></li><li><a href="hello-world-service/hello-world-service.html"><strong>1.3.</strong> Hello World Service</a></li></ul></li><li><a href="value-types/value-types.html"><strong>2.</strong> Value Types</a></li><li><a href="constants/constants.html"><strong>3.</strong> Constants</a></li><li><a href="global-variables/global-variables.html"><strong>4.</strong> Global Variables</a></li><li><a href="while/while.html"><strong>5.</strong> While</a></li><li><a href="if-else/if-else.html"><strong>6.</strong> If Else</a></li><li><a href="functions/functions.html"><strong>7.</strong> Functions</a></li><li><a href="multiple-return-values/multiple-return-values.html"><strong>8.</strong> Multiple Return Values</a></li><li><a href="named-returns/named-returns.html"><strong>9.</strong> Named Returns</a></li><li><a href="errors/errors.html"><strong>10.</strong> Errors</a></li><li><a href="var/var.html"><strong>11.</strong> Var</a></li><li><a href="any-type/any-type.html"><strong>12.</strong> Any Type</a></li><li><a href="type-casting/type-casting.html"><strong>13.</strong> Type Casting</a></li><li><a href="type-conversion/type-conversion.html"><strong>14.</strong> Type Conversion</a></li><li><a href="typeof/typeof.html"><strong>15.</strong> Typeof</a></li><li><a href="structs/structs.html"><strong>16.</strong> Structs</a></li><li><a href="maps/maps.html"><strong>17.</strong> Maps</a></li><li><a href="arrays/arrays.html"><strong>18.</strong> Arrays</a></li><li><ul class="section"><li><a href="array-of-arrays/array-of-arrays.html"><strong>18.1.</strong> Array of Arrays</a></li></ul></li><li><a href="lengthof/lengthof.html"><strong>19.</strong> Lengthof</a></li><li><a href="identifier-literals/identifier-literals.html"><strong>20.</strong> Identifier Literals</a></li><li><a href="json/json.html"><strong>21.</strong> JSON</a></li><li><ul class="section"><li><a href="json-literals/json-literals.html"><strong>21.1.</strong> Literals</a></li><li><a href="json-arrays/json-arrays.html"><strong>21.2.</strong> Arrays</a></li><li><a href="json-struct-map-conversion/json-struct-map-conversion.html"><strong>21.3.</strong> JSON/Struct/Map Conversion</a></li><li><a href="constrained-json/constrained-json.html"><strong>21.4.</strong> Constrained JSON</a></li></ul></li><li><a href="xml/xml.html"><strong>22.</strong> XML</a></li><li><ul class="section"><li><a href="xml-namespaces/xml-namespaces.html"><strong>22.1.</strong> Namespaces</a></li><li><a href="xml-literal/xml-literal.html"><strong>22.2.</strong> Literal</a></li><li><a href="xml-attributes/xml-attributes.html"><strong>22.3.</strong> Attributes</a></li><li><a href="xml-functions/xml-functions.html"><strong>22.4.</strong> Functions</a></li></ul></li><li><a href="json-to-xml-conversion/json-to-xml-conversion.html"><strong>23.</strong> JSON To XML Conversion</a></li><li><a href="xml-to-json-conversion/xml-to-json-conversion.html"><strong>24.</strong> XML To JSON Conversion</a></li><li><a href="worker/worker.html"><strong>25.</strong> Worker</a></li><li><ul class="section"><li><a href="worker-interaction/worker-interaction.html"><strong>25.1.</strong> Worker Interaction</a></li></ul></li><li><a href="fork-join/fork-join.html"><strong>26.</strong> Fork/Join</a></li><li><ul class="section"><li><a href="fork-join-condition-some/fork-join-condition-some.html"><strong>26.1.</strong> Condition Some</a></li><li><a href="fork-join-variable-access/fork-join-variable-access.html"><strong>26.2.</strong> Variable Access</a></li></ul></li><li><a href="sql-connector/sql-connector.html"><strong>27.</strong> SQL Connector</a></li><li><a href="datatables/datatables.html"><strong>28.</strong> Datatables</a></li><li><a href="transactions/transactions.html"><strong>29.</strong> Transactions</a></li><li><a href="transformers/transformers.html"><strong>30.</strong> Transformers</a></li><li><ul class="section"><li><a href="transform-json/transform-json.html"><strong>30.1.</strong> Transform JSON</a></li></ul></li><li><a href="strings/strings.html"><strong>31.</strong> Strings</a></li><li><a href="blob-type/blob-type.html"><strong>32.</strong> Blob Type</a></li><li><a href="date-time/date-time.html"><strong>33.</strong> Date Time</a></li><li><a href="file-api/file-api.html"><strong>34.</strong> File API</a></li><li><a href="throw/throw.html"><strong>35.</strong> Throw</a></li><li><a href="try-catch-finally/try-catch-finally.html"><strong>36.</strong> Try/Catch/Finally</a></li><li><a href="base-path-and-path/base-path-and-path.html"><strong>37.</strong> Base Path and Path</a></li><li><a href="query-and-path-param/query-and-path-param.html"><strong>38.</strong> Query and Path Param</a></li><li><a href="content-based-routing/content-based-routing.html"><strong>39.</strong> Content Based Routing</a></li><li><a href="header-based-routing/header-based-routing.html"><strong>40.</strong> Header Based Routing</a></li><li><a href="produces-consumes/produces-consumes.html"><strong>41.</strong> Produces/Consumes</a></li><li><a href="http-sessions/http-sessions.html"><strong>42.</strong> HTTP Sessions</a></li><li><a href="http-client-connector/http-client-connector.html"><strong>43.</strong> HTTP Client Connector</a></li><li><a href="https-server-connector/https-server-connector.html"><strong>44.</strong> HTTPS Server Connector</a></li><li><a href="https-server-client-connectors/https-server-client-connectors.html"><strong>45.</strong> HTTPS Server/Client Connectors</a></li><li><a href="http-to-websocket-upgrade/http-to-websocket-upgrade.html"><strong>46.</strong> HTTP to WebSocket Upgrade</a></li><li><a href="log-api/log-api.html"><strong>47.</strong> Log API</a></li><li><a href="function-pointers/function-pointers.html"><strong>48.</strong> Function Pointers</a></li><li><a href="lambda/lambda.html"><strong>49.</strong> Lambda</a></li><li><a href="websocket-basic-sample/websocket-basic-sample.html"><strong>50.</strong> WebSocket</a></li><li><ul class="section"><li><a href="websocket-chat-application/websocket-chat-application.html"><strong>50.1.</strong> WebSocket Chat Application</a></li><li><a href="websocket-proxy-server/websocket-proxy-server.html"><strong>50.2.</strong> WebSocket Proxy Server</a></li></ul></li><li><a href="passthrough/passthrough.html"><strong>51.</strong> Passthrough</a></li><li><a href="mutual-ssl/mutual-ssl.html"><strong>52.</strong> Mutual SSL</a></li><li><a href="caching/caching.html"><strong>53.</strong> Caching</a></li><li><a href="byte-io/byte-io.html"><strong>54.</strong> Byte I/O</a></li><li><a href="character-io/character-io.html"><strong>55.</strong> Character I/O</a></li><li><a href="record-i-o/record-i-o.html"><strong>56.</strong> Record I/O</a></li><li><a href="math-functions/math-functions.html"><strong>57.</strong> Math Functions</a></li><li><a href="task-timer/task-timer.html"><strong>58.</strong> Task Timer</a></li><li><a href="task-appointment/task-appointment.html"><strong>59.</strong> Task Appointment</a></li><li><a href="config-api/config-api.html"><strong>60.</strong> Config API</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="edit-button" class="fa fa-edit">Edit</i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Ballerina By Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#ballerina-by-example" id="ballerina-by-example"><h1>Ballerina by Example</h1></a>
<p><a href="https://ballerinalang.org/">Ballerina</a> is a general purpose, concurrent and strongly typed programming language with both textual and graphical syntaxes, optimized for integration.</p>
<p>Ballerina by Example is a hands-on introduction to Ballerina using annotated example programs. Check out the first example or browse the full list below.</p>
<p>Now let's begin!</p>
<ul>
<li><a href="hello-world/hello-world.html">Hello World</a></li>
<li><a href="hello-world-parallel/hello-world-parallel.html">Hello World Parallel</a></li>
<li><a href="hello-world-service/hello-world-service.html">Hello World Service</a></li>
<li><a href="value-types/value-types.html">Value Types</a></li>
<li><a href="constants/constants.html">Constants</a></li>
<li><a href="global-variables/global-variables.html">Global Variables</a></li>
<li><a href="while/while.html">While</a></li>
<li><a href="if-else/if-else.html">If Else</a></li>
<li><a href="functions/functions.html">Functions</a></li>
<li><a href="multiple-return-values/multiple-return-values.html">Multiple Return Values</a></li>
<li><a href="named-returns/named-returns.html">Named Returns</a></li>
<li><a href="errors/errors.html">Errors</a></li>
<li><a href="var/var.html">Var</a></li>
<li><a href="any-type/any-type.html">Any Type</a></li>
<li><a href="type-casting/type-casting.html">Type Casting</a></li>
<li><a href="type-conversion/type-conversion.html">Type Conversion</a></li>
<li><a href="typeof/typeof.html">Typeof</a></li>
<li><a href="structs/structs.html">Structs</a></li>
<li><a href="maps/maps.html">Maps</a></li>
<li><a href="arrays/arrays.html">Arrays</a></li>
<li><a href="array-of-arrays/array-of-arrays.html">Array of Arrays</a></li>
<li><a href="lengthof/lengthof.html">Lengthof</a></li>
<li><a href="identifier-literals/identifier-literals.html">Identifier Literals</a></li>
<li><a href="json/json.html">JSON</a></li>
<li><a href="json-literals/json-literals.html">JSON Literals</a></li>
<li><a href="json-arrays/json-arrays.html">JSON Arrays</a></li>
<li><a href="json-struct-map-conversion/json-struct-map-conversion.html">JSON/Struct/Map Conversion</a></li>
<li><a href="constrained-json/constrained-json.html">Constrained JSON</a></li>
<li><a href="xml/xml.html">XML</a></li>
<li><a href="xml-namespaces/xml-namespaces.html">XML Namespaces</a></li>
<li><a href="xml-literal/xml-literal.html">XML Literal</a></li>
<li><a href="xml-attributes/xml-attributes.html">XML Attributes</a></li>
<li><a href="xml-functions/xml-functions.html">XML Functions</a></li>
<li><a href="json-to-xml-conversion/json-to-xml-conversion.html">JSON To XML Conversion</a></li>
<li><a href="xml-to-json-conversion/xml-to-json-conversion.html">XML To JSON Conversion</a></li>
<li><a href="worker/worker.html">Worker</a></li>
<li><a href="worker-interaction/worker-interaction.html">Worker Interaction</a></li>
<li><a href="fork-join/fork-join.html">Fork/Join</a></li>
<li><a href="fork-join-condition-some/fork-join-condition-some.html">Fork/Join Condition Some</a></li>
<li><a href="fork-join-variable-access/fork-join-variable-access.html">Fork/Join Variable Access</a></li>
<li><a href="sql-connector/sql-connector.html">SQL Connector</a></li>
<li><a href="datatables/datatables.html">Datatables</a></li>
<li><a href="transactions/transactions.html">Transactions</a></li>
<li><a href="transformers/transformers.html">Transformers</a></li>
<li><a href="transform-json/transform-json.html">Transform JSON</a></li>
<li><a href="strings/strings.html">Strings</a></li>
<li><a href="blob-type/blob-type.html">Blob Type</a></li>
<li><a href="date-time/date-time.html">Date Time</a></li>
<li><a href="file-api/file-api.html">File API</a></li>
<li><a href="throw/throw.html">Throw</a></li>
<li><a href="try-catch-finally/try-catch-finally.html">Try/Catch/Finally</a></li>
<li><a href="base-path-and-path/base-path-and-path.html">Base Path and Path</a></li>
<li><a href="query-and-path-param/query-and-path-param.html">Query and Path Param</a></li>
<li><a href="content-based-routing/content-based-routing.html">Content Based Routing</a></li>
<li><a href="header-based-routing/header-based-routing.html">Header Based Routing</a></li>
<li><a href="produces-consumes/produces-consumes.html">Produces/Consumes</a></li>
<li><a href="http-sessions/http-sessions.html">HTTP Sessions</a></li>
<li><a href="http-client-connector/http-client-connector.html">HTTP Client Connector</a></li>
<li><a href="https-server-connector/https-server-connector.html">HTTPS Server Connector</a></li>
<li><a href="https-server-client-connectors/https-server-client-connectors.html">HTTPS Server/Client Connectors</a></li>
<li><a href="http-to-websocket-upgrade/http-to-websocket-upgrade.html">HTTP to WebSocket Upgrade</a></li>
<li><a href="log-api/log-api.html">Log API</a></li>
<li><a href="function-pointers/function-pointers.html">Function Pointers</a></li>
<li><a href="lambda/lambda.html">Lambda</a></li>
<li><a href="websocket-basic-sample/websocket-basic-sample.html">WebSocket Basic Sample</a></li>
<li><a href="websocket-chat-application/websocket-chat-application.html">WebSocket Chat Application</a></li>
<li><a href="websocket-proxy-server/websocket-proxy-server.html">WebSocket Proxy Server</a></li>
<li><a href="passthrough/passthrough.html">Passthrough</a></li>
<li><a href="mutual-ssl/mutual-ssl.html">Mutual SSL</a></li>
<li><a href="caching/caching.html">Caching</a></li>
<li><a href="byte-io/byte-io.html">Byte I/O</a></li>
<li><a href="character-io/character-io.html">Character I/O</a></li>
<li><a href="record-i-o/record-i-o.html">Record I/O</a></li>
<li><a href="math-functions/math-functions.html">Math Functions</a></li>
<li><a href="task-timer/task-timer.html">Task Timer</a></li>
<li><a href="task-appointment/task-appointment.html">Task Appointment</a></li>
<li><a href="config-api/config-api.html">Config API</a></li>
</ul>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello World</h1></a>
<p>Let's print &quot;Hello, World!&quot; using Ballerina. Here's the full source code.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    println(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>To run the program, put the code in &quot;hello-world.bal&quot; and use &quot;ballerina run&quot; command.</p>
<pre><code class="language-bash">$ ballerina run hello-world.bal
Hello, World!
</code></pre>
<a class="header" href="print.html#hello-world-1" id="hello-world-1"><h1>Hello World</h1></a>
<p>Let's print &quot;Hello, World!&quot; using Ballerina. Here's the full source code.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    println(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>To run the program, put the code in &quot;hello-world.bal&quot; and use &quot;ballerina run&quot; command.</p>
<pre><code class="language-bash">$ ballerina run hello-world.bal
Hello, World!
</code></pre>
<a class="header" href="print.html#hello-world-parallel" id="hello-world-parallel"><h1>Hello World Parallel</h1></a>
<p>Let's print &quot;Hello, World!&quot; in parallel using Ballerina. Here we use workers which represent parallel threads of execution in Ballerina.</p>
<pre><pre class="playpen"><code class="language-ballerina">// Workers don’t need to be explicitly started. They start at the same time as the
// default worker
function main (string[] args) {

    worker w1 {
        println(&quot;Hello, World! #m&quot;);
    }

    worker w2 {
        println(&quot;Hello, World! #n&quot;);
    }

    worker w3 {
        println(&quot;Hello, World! #k&quot;);
    }
}
</code></pre></pre>
<p>To run the program, put the code in &quot;hello-world-parallel.bal&quot; and use &quot;ballerina run&quot; command.</p>
<pre><code class="language-bash">$ ballerina run hello-world-parallel.bal
Hello, World! #m
Hello, World! #k
Hello, World! #n
</code></pre>
<a class="header" href="print.html#hello-world-service" id="hello-world-service"><h1>Hello World Service</h1></a>
<p>Services represent collections of network accessible entry points in Ballerina.
Resources represent one such entry point.</p>
<p>Exactly how the resource is exposed over a network protocol is dependent on the server connector in use for the service as well as on annotations that are given for the specific resource.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

// By default Ballerina assumes that the service is to be exposed via HTTP/1.1
// using the system default port
service&lt;http&gt; helloWorld {
    // All resources are invoked with arguments of request and response
    resource sayHello (http:Request req, http:Response res) {
        // A util method that can be used to set string payload.
        res.setStringPayload(&quot;Hello, World!&quot;);
        // Sends the response back to the client.
        _ = res.send();
    }
}
</code></pre></pre>
<p>To start the service, put the code in &quot;hello-world-service.bal&quot; and use &quot;ballerina run&quot; command.</p>
<pre><code class="language-bash">$ ballerina run hello-world-service.bal
ballerina: deploying service(s) in 'hello-world-service.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<p>To build a compiled program file, we can use the &quot;ballerina build&quot; command followed by the service package.</p>
<pre><code class="language-bash">$ ballerina build hello-world-service.bal
$ ls
hello-world-service.balx	hello-world-service.bal
</code></pre>
<p>Invoke the service using &quot;curl&quot;.</p>
<pre><code class="language-bash">$ curl http://localhost:9090/helloWorld/sayHello
Hello, World!
</code></pre>
<a class="header" href="print.html#value-types" id="value-types"><h1>Value Types</h1></a>
<p>The Ballerina type system has value types and reference types. All value typed variables are allocated on the stack.
Ballerina Value types include int, float, string, boolean and blob.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Variables defined without an initial value are zero-valued.
    // For example, the zero value for an int is 0.
    int i;
    println(i);

    float f = 20.0;
    println(f);

    //The zero value of a string is &quot;&quot;.
    string s;
    println(s);

    boolean b = true;
    println(b);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run value-types.bal
0
20.0

true
</code></pre>
<a class="header" href="print.html#constants" id="constants"><h1>Constants</h1></a>
<p>The Ballerina supports value typed constants except for blob type.</p>
<pre><pre class="playpen"><code class="language-ballerina">// A const declaration can appear only as a top-level construct in Ballerina
const float PI = 3.14159;

function main (string[] args) {
    float circumference = 10.4;
    float diameter = circumference / PI;
    println(&quot;Diameter of the circle: &quot; + diameter);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run constants.bal
Diameter of the circle: 3.310425612508316
</code></pre>
<a class="header" href="print.html#global-variables" id="global-variables"><h1>Global Variables</h1></a>
<p>In Ballerina, global variables are defined as top level constructs.
They are usually defined on top of the Ballerina program.
The global variables holds their value throughout the lifetime of the Ballerina program.</p>
<pre><pre class="playpen"><code class="language-ballerina">// Global variable declaration
int total = 98;

string content = &quot;&quot;;

function main (string[] args) {

    //Accessing a global variable.
    println(total);

    content = content + &quot;This is a sample text\n&quot;;
    println(content);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run global-variables.bal
98
This is a sample text
</code></pre>
<a class="header" href="print.html#while" id="while"><h1>While</h1></a>
<p>Ballerina has only one looping construct. Here is an example usage of while.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {

    int i = 0;
    //This is a basic while loop.
    while (i &lt; 3) {
        println(i);
        i = i + 1;
    }

    int j = 0;
    while (j &lt; 5) {
        println(j);
        j = j + 1;

        //Use the break statement if you want to break the loop.
        if (j == 3) {
            break;
        }
    }

    int k = 0;
    while (k &lt; 5) {
        //Sample usage of the next statement.
        if (k &lt; 3) {
            k = k + 1;
            next;
        }

        println(k);
        k = k + 1;
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run while.bal
0
1
2
0
1
2
3
4
</code></pre>
<a class="header" href="print.html#if-else" id="if-else"><h1>If Else</h1></a>
<p>An if statement provides a way to perform conditional execution.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    int a = 10;
    int b = 0;

    //Here’s a basic example for scenario with if condition.
    if (a == 10) {
        println(&quot;a == 10&quot;);
    }

    //If else scenario.
    if (a &lt; b) {
        println(&quot;a &lt; b&quot;);
    } else {
        println(&quot;a &gt;= b&quot;);
    }

    //Else-if scenario.
    if (b &lt; 0) {
        println(&quot;b &lt; 0&quot;);
    } else if (b &gt; 0) {
        println(&quot;b &gt; 0&quot;);
    } else {
        println(&quot;b == 0&quot;);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run if-else.bal
a == 10
a &gt;= b
b == 0
</code></pre>
<a class="header" href="print.html#functions" id="functions"><h1>Functions</h1></a>
<p>Functions are like functions in any other language and are a mechanism to create a reusable unit of functionality.</p>
<pre><pre class="playpen"><code class="language-ballerina">// This function takes a string argument.
function printValue (string value) {
    println(value);
}

// This function takes two int values and return their sum as an int.
function add (int a, int b) (int) {
    return a + b;
}

function main (string[] args) {
    // Call a function which prints the given value to the console.
    printValue(&quot;This is a sample text&quot;);

    // Directly print a value to the console.
    int result = add(5, 6);
    print(result);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run functions.bal
This is a sample text
11
</code></pre>
<a class="header" href="print.html#multiple-return-values" id="multiple-return-values"><h1>Multiple Return Values</h1></a>
<p>Ballerina functions can return many values at once instead of just one as is commonly done in most imperative languages.</p>
<pre><pre class="playpen"><code class="language-ballerina">// Here's a function which returns two int values.
function divideBy10 (int d) (int, int) {
    return d / 10, d % 10;
}

function main (string[] args) {
    int q;
    int r;
    //Multiple variable assignment.
    q, r = divideBy10(24);
    println(&quot;24/10: &quot; + &quot;quotient=&quot; + q + &quot; &quot; + &quot;remainder=&quot; + r);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run multiple-return-values.bal
24/10: quotient=2 remainder=4
</code></pre>
<a class="header" href="print.html#named-returns" id="named-returns"><h1>Named Returns</h1></a>
<p>Return values in the function signature can be named in Ballerina. They should be used to document the meaning of the return values.</p>
<pre><pre class="playpen"><code class="language-ballerina">// These names are treated as variables defined at the top of the function.
function divideBy10 (int d) (int quotient, int remainder) {
    return d / 10, d % 10;
}

// If the return statement does not contain any argument then the named return
// values will be returned.
function divideBy5 (int d) (int quotient, int remainder) {
    quotient = d / 5;
    remainder = d % 5;
    return;
}

// Named return variables are treated as local variables and will be initialized
// to their zero value.
function getDefaultValues () (int a, float b,
                              boolean c, string d) {
    return a, b, c, d;
}


function main (string[] args) {
    var q1, r1 = divideBy10(93);
    println(&quot;93/10: &quot; + &quot;quotient=&quot; + q1 + &quot; &quot; + &quot;remainder=&quot; + r1);

    var q2, r2 = divideBy5(93);
    println(&quot;93/5: &quot; + &quot;quotient=&quot; + q2 + &quot; &quot; + &quot;remainder=&quot; + r2);

    int a;
    float b;
    boolean c;
    string d;
    a, b, c, d = getDefaultValues();

    println(&quot;a: &quot; + a);
    println(&quot;b: &quot; + b);
    println(&quot;c: &quot; + c);
    println(&quot;d: &quot; + d);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run named-returns.bal
93/10: quotient=9 remainder=3
93/5: quotient=18 remainder=3
a: 0
b: 0.0
c: false
d:
</code></pre>
<a class="header" href="print.html#errors" id="errors"><h1>Errors</h1></a>
<p>Ballerina errors can both be returned as yet another return value or be thrown.
Any Ballerina error type should structurally equivalent to the ballerina.lang.errors:Error struct.</p>
<pre><pre class="playpen"><code class="language-ballerina">// As a best practice, error will be the last return value.
// It's type should be 'errors:Error', a built-in reference type.
function getAccountBalance (int accountID) (int, error) {
    //Here we create an instance of the error struct and return.
    //This logic is used only to explain the concept.
    if (accountID &lt; 100) {
        error err = {msg:&quot;Account with id:&quot; + accountID + &quot; is not found&quot;};
        return 0, err;
    } else {
        return 600, null;
    }
}

function main (string[] args) {
    // Best practice is to check whether an error has occurred.
    var balance, err = getAccountBalance(23);
    if (err != null) {
        println(&quot;error: &quot; + err.msg);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run errors.bal
error: Account with id:23 is not found
</code></pre>
<a class="header" href="print.html#var" id="var"><h1>Var</h1></a>
<p>Ballerina supports variable declarations with &quot;var&quot;.</p>
<pre><pre class="playpen"><code class="language-ballerina">function divideBy10 (int d) (int, int) {
    return d / 10, d % 10;
}

function main (string[] args) {
    //Here the variable type is inferred type from the initial value.
    // This is same as &quot;int k = 5&quot;;
    var k = 5;
    println(10 + k);

    //Here the type of the 'strVar' is 'string'.
    var strVar = &quot;Hello!&quot;;
    println(strVar);

    //Multiple assignment with 'var' allows you to define the variable then and there.
    //Variable type is inferred from the right-hand side.
    var q, r = divideBy10(6);
    println(&quot;06/10: &quot; + &quot;quotient=&quot; + q + &quot; &quot; + &quot;remainder=&quot; + r);

    //To ignore a particular return value in a multiple assignment statement, use '_'.
    var q1, _ = divideBy10(57);
    println(&quot;57/10: &quot; + &quot;quotient=&quot; + q1);

    var _, r1 = divideBy10(9);
    println(&quot;09/10: &quot; + &quot;remainder=&quot; + r1);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run var.bal
15
Hello!
06/10: quotient=0 remainder=6
57/10: quotient=5
09/10: remainder=9
</code></pre>
<a class="header" href="print.html#any-type" id="any-type"><h1>Any Type</h1></a>
<p>'any' is the root of the Ballerina data types. It represents a variable of any data type in the type system.
It is a powerful way to deal with variables that we do not know during the compile time.
Values of these variables can come from dynamic content, e.g. request and response messages, user input etc.
Any type allows you to skip compile-time type checks</p>
<pre><pre class="playpen"><code class="language-ballerina">// This function return an 'any' typed value.
function getValue () (any) {
    string name = &quot;cat&quot;;
    return name;
}

function main (string[] args) {
    //'any' typed variable 'a' holds a value of type int.
    any a = 5;
    println(a);

    //You need to cast an 'any' typed variable to the required type first.
    // You can find more about type casting in the next section.
    var intVal, _ = (int)a;
    println(intVal + 10);

    //You can assign a variable of any data type in Ballerina to 'any' typed variable
    int[] ia = [1, 3, 5, 6];
    any ar = ia;
    println(ar);

    println(getValue());
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-ballerina">$ ballerina run any-type.bal
5
15
[1, 3, 5, 6]
cat
</code></pre></pre>
<a class="header" href="print.html#type-casting" id="type-casting"><h1>Type Casting</h1></a>
<p>Type casting allows you to look at a value as being of a different type than it’s original type.
There are safe and unsafe casts. For unsafe casts, Ballerina compiler will enforce you to use multi-return cast expression.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here we assign a 'string' typed value to a variable of type 'any'.
    any a = &quot;Jungle cat&quot;;
    //Here is how you can cast an 'any' typed variable to the 'string' type.
    //This cast is an unsafe, because the value of the variable 'a' is unknown till
    // runtime.
    //Therefore the compiler will enforce you to use multi-return type cast expression.
    var s, castErr = (string)a;
    if(castErr != null) {
        println(&quot;error: &quot; + castErr.msg);
    } else {
        println(s);
    }    
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run type-casting.bal
Jungle cat
</code></pre>
<a class="header" href="print.html#type-conversion" id="type-conversion"><h1>Type Conversion</h1></a>
<p>Type conversion transforms the value so that it can be interpreted as belonging to another type.
There are safe and unsafe conversions. For unsafe conversions, Ballerina compiler will enforce you to use multi-return conversion expression.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //'float' to 'int' conversion is considered as a type conversion in Ballerina,
    // because the underlying representation of the value changes with this conversion.
    float f = 10.0;
    var i = &lt;int&gt;f;
    println(i);

    //'int' to 'string' conversion is always safe.
    int intVal = 45;
    var strVal = &lt;string&gt;intVal;

    //'string' to 'int' conversion is not always safe.
    // Therefore we consider it as an unsafe conversion.
    //Compiler will enforce you to use multi-return conversion expression as follows.
    strVal = &quot;Sri Lanka&quot;;
    var intVal, conversionErr = &lt;int&gt;strVal;
    if (conversionErr != null) {
        println(&quot;error: &quot; + conversionErr.msg);
    }

    //If you know that this conversion will always be successful, you can ignore the
    // error as follows.
    strVal = &quot;5&quot;;
    var val, _ = &lt;int&gt;strVal;
    println(val);

    //'boolean' to 'int' conversion is always safe. You get 0 for 'false' value and 1
    // for 'true' value.
    boolean boolVal = true;
    intVal = &lt;int&gt;boolVal;
    println(intVal);

    //'int' to 'boolean' conversion. The boolean value will be 'false' only if the int
    // value is 0.
    intVal = -10;
    boolVal = &lt;boolean&gt; intVal;
    println(boolVal);

    //'string' to 'boolean' conversion.
    strVal = &quot;true&quot;;
    boolVal, _ = &lt;boolean&gt;strVal;
    println(boolVal);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run type-conversion.bal
10
error: 'string' cannot be converted to 'int'
5
1
true
true
</code></pre>
<a class="header" href="print.html#typeof" id="typeof"><h1>Typeof</h1></a>
<p>Ballerina supports 'typeof' which returns the type of a variable.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here you create 'any' typed variable.
    any variable;
    //Assign an integer variable to 'any' typed variable.
    variable = 5;

    //Use 'typeof' unary operator to return type of variable.
    type typeOfVariable = (typeof variable);

    //Use 'typeof' unary operator to return type from type name.
    type intType = (typeof int);

    //Check for runtime type equivalency of 'any' typed variable.
    if (typeOfVariable == intType) {
        println(&quot;This 'variable' is an integer typed variable.&quot;);
    } else {
        println(&quot;This 'variable' is 'NOT' an integer typed variable.&quot;);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run typeof.bal
This 'variable' is an integer typed variable.
</code></pre>
<a class="header" href="print.html#structs" id="structs"><h1>Structs</h1></a>
<p>Structs in ballerina is the way to create new user-defined data types. They are collections of typed fields.</p>
<pre><pre class="playpen"><code class="language-ballerina">//Defining a Person struct. Contains field names and their types.
//Optionally, for value type fields, can define the default value.
//Otherwise, the default value will be set to the zero-value.
struct Person {
    string name;
    int age = -1;
    Person parent;
    string status;
}

function main (string[] args) {
    //Create a person with default values.
    Person p1 = {};
    println(p1);

    //Create a person struct. Values can be set to any field when initializing.
    //Other fields will have their default values.
    Person p2 = {name:&quot;Jack&quot;, age:20, parent:p1};
    println(p2);

    //Get a value of a field of a struct. Fields can be accessed using dot(.)
    //notation or using index.
    println(p2.name);
    println(p2[&quot;name&quot;]);

    //Get the field of a nested struct.
    println(p2.parent.age);

    //Set the value of a field.
    p1.name = &quot;Peter&quot;;
    p1.age = 25;
    println(p1);
    println(p2);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run structs.bal
{name:&quot;&quot;, age:-1, parent:null, status:&quot;&quot;}
{name:&quot;Jack&quot;, age:20, parent:{name:&quot;&quot;, age:-1, parent:null, status:&quot;&quot;}, status:&quot;&quot;}
Jack
Jack
-1
{name:&quot;Peter&quot;, age:25, parent:null, status:&quot;&quot;}
{name:&quot;Jack&quot;, age:20, parent:{name:&quot;Peter&quot;, age:25, parent:null, status:&quot;&quot;}, status:&quot;&quot;}
</code></pre>
<a class="header" href="print.html#maps" id="maps"><h1>Maps</h1></a>
<p>The 'map' type is a hash map with keys of type string to values of 'any' type.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here's how you create an empty map.
    map m = {};

    //Here's how you create a map with initial values.
    map addrMap = {line1:&quot;No. 20&quot;, line2:&quot;Palm Grove&quot;,
                      city:&quot;Colombo 03&quot;, country:&quot;Sri Lanka&quot;};
    println(addrMap);

    //You can retrieve a value of a key using an index based notation as follows.
    var country, _ = (string)addrMap[&quot;country&quot;];
    println(country);

    //Another way to retrieve a value from a map.
    var city, _ = (string)addrMap.city;
    println(city);

    //Here's how you can add or update the value of a key.
    addrMap[&quot;postalCode&quot;] = &quot;00300&quot;;
    addrMap.postalCode = &quot;00301&quot;;
    println(addrMap);

    //You can use 'keys' function in the 'maps' package get an array keys.
    println(addrMap.keys());

    //Number of keys in the map.
    println(lengthof addrMap);

    //You can remove a key using the 'remove' method.
    addrMap.remove(&quot;postalCode&quot;);
    println(addrMap);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run maps.bal
{&quot;line1&quot;:&quot;No. 20&quot;, &quot;line2&quot;:&quot;Palm Grove&quot;, &quot;city&quot;:&quot;Colombo 03&quot;, &quot;country&quot;:&quot;Sri Lanka&quot;}
Sri Lanka
Colombo 03
{&quot;line1&quot;:&quot;No. 20&quot;, &quot;line2&quot;:&quot;Palm Grove&quot;, &quot;city&quot;:&quot;Colombo 03&quot;, &quot;country&quot;:&quot;Sri Lanka&quot;,
    &quot;postalCode&quot;:&quot;00301&quot;}
[&quot;country&quot;, &quot;city&quot;, &quot;postalCode&quot;, &quot;line2&quot;, &quot;line1&quot;]
5
{&quot;line1&quot;:&quot;No. 20&quot;, &quot;line2&quot;:&quot;Palm Grove&quot;, &quot;city&quot;:&quot;Colombo 03&quot;, &quot;country&quot;:&quot;Sri Lanka&quot;}
</code></pre>
<a class="header" href="print.html#arrays" id="arrays"><h1>Arrays</h1></a>
<p>All arrays are unbounded in length and support 0 based indexing. Arrays may be sparse as well and they will grow to meet whatever size needed based on the index (subject to memory availability of course).</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here is how you can create an int array of length 0.
    int[] a = [];
    println(lengthof a);

    //Here is how you can create an array with initial values.
    a = [1, 2, 3, 4, 5, 6, 7, 8];
    println(lengthof a);

    //Arrays are unbounded in length. There arrays will grow whatever size needed
    //based on the given index. Now the length of the following array should be 1000.
    a[999] = 23;
    println(a[999]);
    println(lengthof a);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run arrays.bal
0
8
23
1000
</code></pre>
<a class="header" href="print.html#array-of-arrays" id="array-of-arrays"><h1>Array of Arrays</h1></a>
<p>Ballerina support array of arrays. Following example shows how to initialize, set and access values from array of arrays.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here is how you can initialize an array of int arrays.
    int[][] xx = [[1, 2, 3], [10, 20, 30], [5, 6, 7]];
    println(lengthof xx);
    println(lengthof xx[0]);

    // Initialize three dimensional array with one value. In this case value is a
    // two dimensional array.
    int[][][] xxx = [xx];
    xxx[0][0][1] = 10;
    println(xxx[0][0][1]);

    // Initialize the outer most array of the two dimensional array with
    // empty value.
    int[][] aa = [];

    // Set the initialized one dimensional array to the two dimensional array.
    int[] a = [9];
    aa[0] = a;

    // Print the first value of two dimensional array.
    println(xx[0][0]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run array-of-arrays.bal
3
3
10
1
</code></pre>
<a class="header" href="print.html#lengthof" id="lengthof"><h1>Lengthof</h1></a>
<p>Ballerina supports 'lengthof' which returns the length of an array.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Here you create integer array with with several integer elements.
    int[] intArray = [1, 2, 3];

    int arrayLength;

    //Print the length of the created integer array calculated by the 'lengthof'
    // unary operator.
    arrayLength = lengthof intArray;
    println(&quot;Integer array size : &quot; + arrayLength);


    //Here you create JSON array with several JSON elements.
    json jsonArray = [{&quot;name&quot;:&quot;John&quot;, &quot;age&quot;:31},
                      {&quot;name&quot;:&quot;Neal&quot;, &quot;age&quot;:22}];

    //Print the length of the created JSON array calculated by the 'lengthof'
    // unary operator.
    arrayLength = lengthof jsonArray;
    println(&quot;JSON array size : &quot; + arrayLength);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run lengthof.bal
Integer array size : 3
JSON array size : 2
</code></pre>
<a class="header" href="print.html#identifier-literals" id="identifier-literals"><h1>Identifier Literals</h1></a>
<p>Ballerina supports Identifier literals, that means, it is possible to define symbols without restrictions like &quot;no spaces, no special character&quot; etc. in Ballerina.</p>
<p>Ballerina allows identifiers to contain spaces and use any set of Unicode code points.</p>
<p>We use identifiers to name, functions, service, structs, variables etc.
In Ballerina, identifiers will be defined as &quot;traditional&quot; identifiers or identifier literals.
Identifier literals allows you to use spaces and any set of Unicode code points.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //The vertical bar (|) character is used to demarcate the identifier name.
    //This is similar to string literals (using double quote characters to demarcate).
    string |first name| = &quot;John&quot;;
    string |last name| = &quot;Gosling&quot;;

    //Invoking a function with identifier literal as a parameter.
    string name = |combine names|(|first name|, |last name|);
    println(name);
}

//Sample function defined with function name and input parameters using identifier
//literals.
function |combine names| (string |first name|,
                          string |last name|) (string) {
    return |first name| + &quot; &quot; + |last name|;
}

//Struct defined using identifier literals.
struct |person record| {
    string |first name|;
    string |last name|;
    int age;
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run identifier-literals.bal
John Gosling
</code></pre>
<a class="header" href="print.html#json" id="json"><h1>JSON</h1></a>
<p>JSON is a textual format for representing a collection of values: a simple value (string, number, “true”, “false”, “null”), an array of values or an object.
Ballerina has a single type named “json” that can represent any JSON value.
Thus it is a built-in union type in Ballerina whose value can be any one of a string, a float, a boolean, an array of any or a map of any.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    // JSON string value.
    json j1 = &quot;Apple&quot;;
    println(j1);

    // JSON number value.
    json j2 = 5.36;
    println(j2);

    // JSON true value.
    json j3 = true;
    println(j3);

    // JSON false value.
    json j4 = false;
    println(j4);

    // JSON null value.
    json j5 = null;

    //JSON Objects.
    json j6 = {name:&quot;apple&quot;, color:&quot;red&quot;, price:j2};
    println(j6);

    //JSON Arrays. They are arrays of any JSON value.
    json j7 = [1, false, null, &quot;foo&quot;,
               {first:&quot;John&quot;, last:&quot;Pala&quot;}];
    println(j7);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run json.bal
Apple
5.36
true
false
{&quot;name&quot;:&quot;apple&quot;,&quot;color&quot;:&quot;red&quot;,&quot;price&quot;:5.36}
[1,false,null,&quot;foo&quot;,{&quot;first&quot;:&quot;John&quot;,&quot;last&quot;:&quot;Pala&quot;}]
</code></pre>
<a class="header" href="print.html#json-literals" id="json-literals"><h1>JSON Literals</h1></a>
<p>JSON literals are written exactly the same way as Ballerina structs and maps.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {

    //Creates an empty JSON Object.
    json empty = {};

    int age = 30;
    //Create a JSON object. Keys can be defined with or without quotes.
    //Values can be any expression.
    json p = {fname:&quot;John&quot;, lname:&quot;Stallone&quot;, &quot;age&quot;:age};
    println(p);

    //You can access the object values by using dot (.) notation or array index
    //notation.
    json firstName = p.fname;
    println(firstName);

    //Array index notation allows you use any string valued expression as the index.
    json lastName = p[&quot;lname&quot;];
    println(lastName);

    //Add or change object values.
    p.lname = &quot;Silva&quot;;
    p[&quot;age&quot;] = 31;
    println(p);

    //Nested JSON objects.
    json p2 = {
                  fname:&quot;Peter&quot;,
                  lname:&quot;Stallone&quot;,
                  &quot;age&quot;:age,
                  address:{
                              line:&quot;20 Palm Grove&quot;,
                              city:&quot;Colombo 03&quot;,
                              country:&quot;Sri Lanka&quot;
                          }
              };
    println(p2);

    p2.address.province = &quot;Western&quot;;
    println(p2);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run json-literals.bal
{&quot;fname&quot;:&quot;John&quot;,&quot;lname&quot;:&quot;Stallone&quot;,&quot;age&quot;:30}
John
Stallone
{&quot;fname&quot;:&quot;John&quot;,&quot;lname&quot;:&quot;Silva&quot;,&quot;age&quot;:31}
{&quot;fname&quot;:&quot;Peter&quot;,&quot;lname&quot;:&quot;Stallone&quot;,&quot;age&quot;:30,
    &quot;address&quot;:{&quot;line&quot;:&quot;20 Palm Grove&quot;,&quot;city&quot;:&quot;Colombo 03&quot;,&quot;country&quot;:&quot;Sri Lanka&quot;}}
{&quot;fname&quot;:&quot;Peter&quot;,&quot;lname&quot;:&quot;Stallone&quot;,&quot;age&quot;:30,
    &quot;address&quot;:{&quot;line&quot;:&quot;20 Palm Grove&quot;,&quot;city&quot;:&quot;Colombo 03&quot;,
        &quot;country&quot;:&quot;Sri Lanka&quot;,&quot;province&quot;:&quot;Western&quot;}}
</code></pre>
<a class="header" href="print.html#json-arrays" id="json-arrays"><h1>JSON Arrays</h1></a>
<p>JSON array literals are written exactly the same way as Ballerina arrays except that they’re 1-dimensional only.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //JSON Arrays. They are arrays of any JSON value.
    json j1 = [1, false, null, &quot;foo&quot;,
               {first:&quot;John&quot;, last:&quot;Pala&quot;}];
    println(j1);

    // Access JSON array elements by index.
    json j2 = j1[4];
    println(j2.first);

    // Add or change elements in a JSON array.
    j1[4] = 8.00;
    println(j1);

    // JSON array in an object literal.
    json p = {
                 fname:&quot;John&quot;, lname:&quot;Stallone&quot;,
                 family:[{fname:&quot;Peter&quot;, lname:&quot;Stallone&quot;},
                         {fname:&quot;Emma&quot;, lname:&quot;Stallone&quot;},
                         {fname:&quot;Jena&quot;, lname:&quot;Stallone&quot;},
                         {fname:&quot;Paul&quot;, lname:&quot;Stallone&quot;}]
             };
    p.family[2].fname = &quot;Alisha&quot;;
    println(p);

    // Get the length of the JSON array.
    json family = p.family;
    int l = lengthof family;
    println(&quot;length of array: &quot; + l);

    // Loop through the array.
    int i = 0;
    while (i &lt; l) {
        println(family[i]);
        i = i + 1;
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run json-arrays.bal
[1,false,null,&quot;foo&quot;,{&quot;first&quot;:&quot;John&quot;,&quot;last&quot;:&quot;Pala&quot;}]
John
[1,false,null,&quot;foo&quot;,8.0]
{&quot;fname&quot;:&quot;John&quot;,&quot;lname&quot;:&quot;Stallone&quot;,
 &quot;family&quot;:[{&quot;fname&quot;:&quot;Peter&quot;,&quot;lname&quot;:&quot;Stallone&quot;},
           {&quot;fname&quot;:&quot;Emma&quot;,&quot;lname&quot;:&quot;Stallone&quot;},
           {&quot;fname&quot;:&quot;Alisha&quot;,&quot;lname&quot;:&quot;Stallone&quot;},
           {&quot;fname&quot;:&quot;Paul&quot;,&quot;lname&quot;:&quot;Stallone&quot;}]}
length of array: 4
{&quot;fname&quot;:&quot;Peter&quot;,&quot;lname&quot;:&quot;Stallone&quot;}
{&quot;fname&quot;:&quot;Emma&quot;,&quot;lname&quot;:&quot;Stallone&quot;}
{&quot;fname&quot;:&quot;Alisha&quot;,&quot;lname&quot;:&quot;Stallone&quot;}
{&quot;fname&quot;:&quot;Paul&quot;,&quot;lname&quot;:&quot;Stallone&quot;}
</code></pre>
<a class="header" href="print.html#jsonstructmap-conversion" id="jsonstructmap-conversion"><h1>JSON/Struct/Map Conversion</h1></a>
<p>We use Ballerina structs, maps and JSON objects to hold records, where records are collections of fields with each field value accessed by a key.
Converting from one type to another is very useful in certain situations.</p>
<pre><pre class="playpen"><code class="language-ballerina">struct person {
    string fname;
    string lname;
    int age;
}

struct movie {
    string title;
    string year;
    string released;
    person writer;
}

function main (string[] args) {
    movie theRevenant = {title:&quot;The Revenant&quot;, year:&quot;2015&quot;,
                            released:&quot;08 Jan 2016&quot;,
                            writer:{fname:&quot;Michael&quot;,
                                       lname:&quot;Punke&quot;, age:30}};
    //Here's how you can convert a struct to a JSON object.
    //This conversion is unsafe.
    var j, _ = &lt;json&gt;theRevenant;
    println(j);
    println(j.writer.lname);

    // Similarly you can convert a struct to a map. This conversion is also safe.
    map m = &lt;map&gt;theRevenant;
    var writer, _ = (person)m[&quot;writer&quot;];
    println(writer.age);

    //'json' to struct conversion. This conversion is unsafe because the field names
    //and type are unknown until runtime.
    json inceptionJ = {title:&quot;Inception&quot;, year:&quot;2010&quot;,
                          released:&quot;16 Jul 2010&quot;,
                          writer:{fname:&quot;Christopher&quot;,
                                     lname:&quot;Nolan&quot;, age:30}};
    var inception, _ = &lt;movie&gt;inceptionJ;
    println(inceptionJ);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run json-struct-map-conversion.bal
{&quot;title&quot;:&quot;The Revenant&quot;,&quot;year&quot;:&quot;2015&quot;,&quot;released&quot;:&quot;08 Jan 2016&quot;,
    &quot;writer&quot;:{&quot;fname&quot;:&quot;Michael&quot;,&quot;lname&quot;:&quot;Punke&quot;,&quot;age&quot;:30}}
Punke
30
{&quot;title&quot;:&quot;Inception&quot;,&quot;year&quot;:&quot;2010&quot;,&quot;released&quot;:&quot;16 Jul 2010&quot;,
    &quot;writer&quot;:{&quot;fname&quot;:&quot;Christopher&quot;,&quot;lname&quot;:&quot;Nolan&quot;,&quot;age&quot;:30}}
</code></pre>
<a class="header" href="print.html#constrained-json" id="constrained-json"><h1>Constrained JSON</h1></a>
<p>A json can be constrained with a struct definition to restrict the fields of the json to that of the struct. If tried to access a field with an invalid field as per the struct definition or initialize a json with invalid fields, this will cause a compilation error.
Restricting the fields of the json will enforce the format of the json variable.</p>
<pre><pre class="playpen"><code class="language-ballerina">// Defining Person struct.
struct Person {
    string name;
    int age;
    string city;
}

function main (string[] args) {
    // Create a new JSON which is constrained by the Person struct. Only the
    // fields defined in the Person struct can be accessed. If we try to
    // access a non existing field, it will produce a compilation error.
    json&lt;Person&gt; person = {name:&quot;Jon&quot;};

    // We can access fields defined in the Person struct without any issue.
    person.age = 25;
    person.city = &quot;Colombo&quot;;
    println(person);

    // We can assign this Constrained JSON to a JSON. This will allow us to
    // add new elements which are not in the struct.
    json employee = person;

    // After that, we can add new elements to the json.
    employee.profession = &quot;Software Engineer&quot;;
    println(employee);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run constrained-json.bal
{&quot;name&quot;:&quot;Jon&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;Colombo&quot;}
{&quot;name&quot;:&quot;Jon&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;Colombo&quot;,&quot;profession&quot;:&quot;Software Engineer&quot;}
</code></pre>
<a class="header" href="print.html#xml" id="xml"><h1>XML</h1></a>
<p>The XML type in Ballerina represents a sequence of zero or more XML items. Each item can be an element, a text, a comment or a processing instruction.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    // XML element. Can only have one root element.
    xml x1 = xml `&lt;book&gt;The Lost World&lt;/book&gt;`;
    println(x1);

    // XML text.
    xml x2 = xml `Hello, world!`;
    println(x2);

    // XML comment.
    xml x3 = xml `&lt;!--I am a comment--&gt;`;
    println(x3);

    // XML processing instruction
    xml x4 = xml `&lt;?target data?&gt;`;
    println(x4);

    // Multiple XML items can be combined to form a sequence of XML. The resulting
    // sequence is again an XML on its own.
    xml x5 = x1 + x2 + x3 + x4;
    println(&quot;\nResulting XML sequence:&quot;);
    println(x5);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml.bal
&lt;book&gt;The Lost World&lt;/book&gt;
Hello, world!
&lt;!--I am a comment--&gt;
&lt;?target data?&gt;

Resulting XML sequence:
&lt;book&gt;The Lost World&lt;/book&gt;Hello, world!&lt;!--I am a comment--&gt;&lt;?target data?&gt;
</code></pre>
<a class="header" href="print.html#xml-namespaces" id="xml-namespaces"><h1>XML Namespaces</h1></a>
<p>Ballerina has built-in support for defining and using XML namespaces.</p>
<pre><pre class="playpen"><code class="language-ballerina">xmlns &quot;http://ballerina.com/aa&quot; as ns0;

function main (string[] args) {
    // Namespaces can be declared at package levels, as well as function level. The
    // identifier followed by 'as' keyword is the prefix bound to this namespace name.
    xmlns &quot;http://ballerina.com/bb&quot; as ns1;

    // Namespace declaration without the prefix, will define a default namespace.
    xmlns &quot;http://ballerina.com/default&quot;;

    // Namespaces can be used for XML qualified names.
    println(ns0:foo);

    // Package level namespaces can be overridden at function level.
    xmlns &quot;http://ballerina.com/updated&quot; as ns0;
    println(ns0:foo);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml-namespaces.bal
{http://ballerina.com/aa}foo
{http://ballerina.com/updated}foo
</code></pre>
<a class="header" href="print.html#xml-literal" id="xml-literal"><h1>XML Literal</h1></a>
<p>Ballerina allows to define XML as part of the language, and syntactically validate. Can interpolate the XML literal with expressions to pass values dynamically during runtime.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {

    //A complex XML defined using the literal syntax, having nested elements of
    //different types.
    xml x1 = xml `&lt;book&gt;
                    &lt;name&gt;Sherlock Holmes&lt;/name&gt;
                    &lt;author&gt;Sir Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: $10--&gt;
                  &lt;/book&gt;`;
    println(x1);

    //Defined namespaces. These are visible to all the XML literals defined from here
    //onwards.
    xmlns &quot;http://ballerina.com/&quot;;
    xmlns &quot;http://ballerina.com/aa&quot; as ns0;

    //Create an XML element. Previously defined namespaces will get added to the
    //element.
    //Can apply the defined prefixes to elements and attributes inside the element.
    xml x2 = xml `&lt;book ns0:status=&quot;available&quot;&gt;
                    &lt;ns0:name&gt;Sherlock Holmes&lt;/ns0:name&gt;
                    &lt;author&gt;Sir Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: $10--&gt;
                  &lt;/book&gt;`;
    println(x2);

    //XML interpolated with expressions, using '{{}}' notation. Expression can be a
    //previously defined variable, arithmetic expressions or even a function call.
    //These expressions get evaluated during runtime.
    string rootTag = &quot;{http://ballerina.com/aa}newBook&quot;;
    string title = &quot;(Sir)&quot;;

    xml x3 = xml `&lt;{{rootTag}}&gt;
                    &lt;name&gt;Sherlock Holmes&lt;/name&gt;
                    &lt;author&gt;{{title}} Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: ${{ 40 / 5 + 4 }}--&gt;
                  &lt;/{{rootTag}}&gt;`;
    println(x3);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml-literal.bal
&lt;book&gt;
                    &lt;name&gt;Sherlock Holmes&lt;/name&gt;
                    &lt;author&gt;Sir Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: $10--&gt;
                  &lt;/book&gt;
&lt;book xmlns=&quot;http://ballerina.com/&quot; xmlns:ns0=&quot;http://ballerina.com/aa&quot; 
    ns0:status=&quot;available&quot;&gt;
                    &lt;ns0:name&gt;Sherlock Holmes&lt;/ns0:name&gt;
                    &lt;author&gt;Sir Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: $10--&gt;
                  &lt;/book&gt;
&lt;ns0:newBook xmlns:ns0=&quot;http://ballerina.com/aa&quot; xmlns=&quot;http://ballerina.com/&quot;&gt;
                    &lt;name&gt;Sherlock Holmes&lt;/name&gt;
                    &lt;author&gt;(Sir) Arthur Conan Doyle&lt;/author&gt;
                    &lt;!--Price: $ 12--&gt;
                  &lt;/ns0:newBook&gt;

</code></pre>
<a class="header" href="print.html#xml-attributes" id="xml-attributes"><h1>XML Attributes</h1></a>
<p>XML elements may have any number of attributes and any number of namespace declarations that apply for that element. In Ballerina both of these types are treated in the same way. Attributes are accessed from an XML sequence using the &quot;@&quot; postfix operator.</p>
<pre><pre class="playpen"><code class="language-ballerina">xmlns &quot;http://ballerina.com/aa&quot; as ns0;

function main (string[] args) {
    //Create an XML element having attributes that are bound to a namespace as well
    //as that are not.
    xml x1 = xml `&lt;ns0:book ns0:status=&quot;available&quot; count=&quot;5&quot;/&gt;`;
    println(x1);

    //A single attribute that is bound to a namespace can be accessed using its
    //qualified name.
    println(x1@[ns0:status]);

    //An attribute can also be accessed using its the string representation of the
    //qualified name.
    string s = x1@[&quot;{http://ballerina.com/aa}status&quot;];
    println(s);

    //An attribute that is not bound to a namespace can be accessed using the string
    //representation of the name.
    println(x1@[&quot;count&quot;]);

    //Accessing an attribute using a dynamic name.
    string attributeName = &quot;count&quot;;
    println(x1@[attributeName]);

    //Update an attribute.
    x1@[ns0:status] = &quot;Not Available&quot;;
    println(x1@[ns0:status]);

    //Getting all the attributes at once, can be done. However this cannot be assigned
    //to any variable.
    println(x1@);

    //To assign all the attributes to a variable, it can be cast to a map. Then the
    //values can be accessed one by one using the map access syntax.
    map attributeMap = &lt;map&gt;x1@;
    println(attributeMap);
    println(attributeMap[&quot;count&quot;]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml-attributes.bal
&lt;ns0:book xmlns:ns0=&quot;http://ballerina.com/aa&quot; ns0:status=&quot;available&quot; count=&quot;5&quot;&gt;
&lt;/ns0:book&gt;
available
available
5
5
Not Available
{&quot;{http://www.w3.org/2000/xmlns/}ns0&quot;:&quot;http://ballerina.com/aa&quot;,
&quot;{http://ballerina.com/aa}status&quot;:&quot;Not Available&quot;,&quot;count&quot;:&quot;5&quot;}
{&quot;{http://www.w3.org/2000/xmlns/}ns0&quot;:&quot;http://ballerina.com/aa&quot;,
&quot;{http://ballerina.com/aa}status&quot;:&quot;Not Available&quot;,&quot;count&quot;:&quot;5&quot;}
5
</code></pre>
<a class="header" href="print.html#xml-functions" id="xml-functions"><h1>XML Functions</h1></a>
<p>Ballerina supports various built-in functions to manipulate XML.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    xml bookName = xml `&lt;name&gt;Book1&lt;/name&gt;`;
    xml bookComment = xml `&lt;!--some comment--&gt;`;
    xml someText = xml `Hello, World!`;
    xml content = someText + bookName + bookComment;

    // Other than the XML literal syntax, XML can be parsed using a string.
    // The string should be a valid XML.
    string xmlString = &quot;&lt;book/&gt;&quot;;
    var book, _ = &lt;xml&gt;xmlString;

    // Get the type of the XML.
    println(bookComment.getItemType());

    // Get the name of an XML element.
    println(bookName.getElementName());

    // Get the text content of an XML.
    println(bookName.getTextValue());

    // Is the XML emtpy?
    println(content.isEmpty());

    // Does the element have only one element?
    println(content.isSingleton());

    // Get a subsequence of an XML sequence.
    xml x = content.slice(2, 3);
    println(x);

    // All the element-type items from an taken from an XML sequence.
    x = content.elements();
    println(x);

    // An element with a particular name can also be retrieved.
    x = content.select(&quot;name&quot;);
    println(x);

    // Set the children of an XML.
    book.setChildren(content);
    println(book);

    // Get all the children of an XML.
    x = book.children();
    println(x);

    // Get a particular child of an XML.
    x = book.selectChildren(&quot;name&quot;);
    println(x);

    // Remove any text items from an XML sequence that are all whitespace.
    x = content.strip();
    println(x);

    // Make a copy of an XML.
    x = bookComment.copy();
    println(x);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml-functions.bal
# Type of the XML
comment
# Name of the XML
name
# Text content of the XML
Book1
# Is the XML emtpy?
false
# Has only one element?
false
# Subsequence of a sequence
&lt;!--some comment--&gt;
# All the element type items
&lt;name&gt;Book1&lt;/name&gt;
# Selected element
&lt;name&gt;Book1&lt;/name&gt;
# XML after setting the children
&lt;book&gt;Hello, World!&lt;name&gt;Book1&lt;/name&gt;&lt;!--some comment--&gt;&lt;/book&gt;
# All the children
Hello, World!&lt;name&gt;Book1&lt;/name&gt;&lt;!--some comment--&gt;
# Selected child
&lt;name&gt;Book1&lt;/name&gt;
# Stripped XML
Hello, World!&lt;name&gt;Book1&lt;/name&gt;&lt;!--some comment--&gt;
# Coppied XML
&lt;!--some comment--&gt;
</code></pre>
<a class="header" href="print.html#json-to-xml-conversion" id="json-to-xml-conversion"><h1>JSON To XML Conversion</h1></a>
<p>JSON to XML conversion can be done using 'toXML' function. This function takes the JSON to be converted and struct of options as arguments.
The options struct has two fields, attributePrefix which is used as the prefix to identify the XML attribute where default value is '@'. And arrayEntryTag as the
name of the tag to be added to each entry of JSON arrays.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Create JSON.
    json j1 = {&quot;Store&quot;:{
                           &quot;@id&quot;:&quot;AST&quot;,
                           &quot;name&quot;:&quot;Anne&quot;,
                           &quot;address&quot;:{
                                         &quot;street&quot;:&quot;Main&quot;,
                                         &quot;city&quot;:&quot;94&quot;
                                     },
                           &quot;codes&quot;:[&quot;4&quot;, &quot;8&quot;]
                       }
              };
    //Convert to XML with default attribute prefix and arrayEntryTag.
    jsonOptions options1 = {};
    xml x1 = j1.toXML(options1);
    println(x1);

    //Convert to XML with custom attribute prefix and custom array tag.
    json j2 = {&quot;Store&quot;:{
                           &quot;#id&quot;:&quot;AST&quot;,
                           &quot;name&quot;:&quot;Anne&quot;,
                           &quot;address&quot;:{
                                         &quot;street&quot;:&quot;Main&quot;,
                                         &quot;city&quot;:&quot;94&quot;
                                     },
                           &quot;codes&quot;:[&quot;4&quot;, &quot;8&quot;]
                       }
              };
    jsonOptions options2 = {attributePrefix:&quot;#&quot;, arrayEntryTag:&quot;wrapper&quot;};
    xml x2 = j2.toXML(options2);
    println(x2);
}

</code></pre></pre>
<pre><code class="language-bash">$ ballerina run json-to-xml-conversion.bal
&lt;Store id=&quot;AST&quot;&gt;&lt;name&gt;Anne&lt;/name&gt;&lt;address&gt;&lt;street&gt;Main&lt;/street&gt;&lt;city&gt;94&lt;/city&gt;
&lt;/address&gt;&lt;codes&gt;&lt;item&gt;4&lt;/item&gt;&lt;item&gt;8&lt;/item&gt;&lt;/codes&gt;&lt;/Store&gt;
&lt;Store id=&quot;AST&quot;&gt;&lt;name&gt;Anne&lt;/name&gt;&lt;address&gt;&lt;street&gt;Main&lt;/street&gt;&lt;city&gt;94&lt;/city&gt;
&lt;/address&gt;&lt;codes&gt;&lt;wrapper&gt;4&lt;/wrapper&gt;&lt;wrapper&gt;8&lt;/wrapper&gt;&lt;/codes&gt;&lt;/Store&gt;
</code></pre>
<a class="header" href="print.html#xml-to-json-conversion" id="xml-to-json-conversion"><h1>XML To JSON Conversion</h1></a>
<p>XML to JSON conversion can be done using 'toJSON' function. This function takes the XML to be converted and struct of options as arguments.
The options struct has two fields, attributePrefix which is the prefix to add to the key, to identify a XML attribute and namespaces where default value is '@'. And preserveNamespaces to indicate whether to preserve namespace prefixes when converting or not.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Create a XML.
    var x, _ = &lt;xml&gt;(&quot;&lt;h:Store id = \&quot;AST\&quot; xmlns:h=\&quot;http://www.test.com\&quot;&gt;&quot; +
                     &quot;&lt;h:name&gt;Anne&lt;/h:name&gt;&quot; +
                     &quot;&lt;h:address&gt;&lt;h:street&gt;Main&lt;/h:street&gt;&quot; +
                     &quot;&lt;h:city&gt;94&lt;/h:city&gt;&lt;/h:address&gt;&quot; +
                     &quot;&lt;h:code&gt;&lt;h:item&gt;4&lt;/h:item&gt;&lt;h:item&gt;8&lt;/h:item&gt;&lt;/h:code&gt;&quot; +
                     &quot;&lt;/h:Store&gt;&quot;);
    //Convert to JSON with default attribute prefix and with namespaces.
    xmlOptions options1 = {};
    json j1 = x.toJSON(options1);
    println(j1);

    //Convert to JSON with custom attribute prefix and without namespaces.
    xmlOptions options2 = {attributePrefix:&quot;#&quot;, preserveNamespaces:false};
    json j2 = x.toJSON(options2);
    println(j2);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run xml-to-json-conversion.bal
{&quot;h:Store&quot;:{&quot;@xmlns:h&quot;:&quot;http://www.test.com&quot;,&quot;@id&quot;:&quot;AST&quot;,&quot;h:name&quot;:&quot;Anne&quot;,
&quot;h:address&quot;:{&quot;h:street&quot;:&quot;Main&quot;,&quot;h:city&quot;:&quot;94&quot;},&quot;h:code&quot;:{&quot;h:item&quot;:[&quot;4&quot;,&quot;8&quot;]}}}
{&quot;Store&quot;:{&quot;#id&quot;:&quot;AST&quot;,&quot;name&quot;:&quot;Anne&quot;,&quot;address&quot;:{&quot;street&quot;:&quot;Main&quot;,&quot;city&quot;:&quot;94&quot;},
&quot;code&quot;:{&quot;item&quot;:[&quot;4&quot;,&quot;8&quot;]}}}
</code></pre>
<a class="header" href="print.html#worker" id="worker"><h1>Worker</h1></a>
<p>Workers in ballerina allow developers to delegate their tasks to parallel running threads(workers).
Workers can be declared within functions, actions or resources. The logic written inside a worker block is executed in a parallel thread
to the default (main) thread.</p>
<p>Worker execution starts immediately after invoking the relevant function, action or resource which encloses the worker(s).</p>
<pre><pre class="playpen"><code class="language-ballerina">// Workers in ballerina allow users to delegate tasks to a new worker thread.
function main (string[] args) {
    worker w1 {
        int iw = 200;
        float kw = 5.44;
        println(&quot;[w1] iw: &quot; + iw + &quot; kw: &quot; + kw);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run worker.bal
[w1] iw: 200 kw: 5.44
</code></pre>
<a class="header" href="print.html#worker-interaction" id="worker-interaction"><h1>Worker Interaction</h1></a>
<p>Workers interact with each other by sending messages. Messages are sent over a channel but the channels are anonymous.</p>
<pre><pre class="playpen"><code class="language-ballerina">//Workers interact with each other by sending and receiving messages.
//Ballerina checks the send/receive signatures of every pair of workers and
//validate in order to avoid deadlocks.
function main (string[] args) {

    worker w1 {
        int i = 100;
        float k = 2.34;
        println(&quot;[w1 -&gt; w2] i: &quot; + i + &quot; k: &quot; + k);
        //Send a messages to worker 'w2'. This message contains two values of type
        //int and float.
        i, k -&gt; w2;
        //Receive a message from worker w2. This message contains a json typed value.
        json j = {};
        j &lt;- w2;
        println(&quot;[w1 &lt;- w2] j: &quot; + j.toString());
    }

    worker w2 {
        //Receive a message from default worker.
        int iw;
        float kw;
        iw, kw &lt;- w1;
        println(&quot;[w2 &lt;- w1] iw: &quot; + iw + &quot; kw: &quot; + kw);
        //Send a message to default worker.
        json jw = {&quot;name&quot;:&quot;Ballerina&quot;};
        println(&quot;[w2 -&gt; w1] jw: &quot; + jw.toString());
        jw -&gt; w1;
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run worker-interaction.bal
[w1 -&gt; w2] i: 100 k: 2.34
[w2 &lt;- w1] iw: 100 kw: 2.34
[w2 -&gt; w1] jw: {&quot;name&quot;:&quot;Ballerina&quot;}
[w1 &lt;- w2] j: {&quot;name&quot;:&quot;Ballerina&quot;}
</code></pre>
<a class="header" href="print.html#forkjoin" id="forkjoin"><h1>Fork/Join</h1></a>
<p>A fork statement allows one to start any number of parallel workers at once.
The join part of the fork statement allows one to define how the caller of fork will wait for the parallel workers to complete.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //The fork-join allows developers to spawn(fork) multiple workers within a
    // ballerina program and join the results from those workers and execute code on
    //joined results.
    fork {
        worker w1 {
            int i = 23;
            string s = &quot;Colombo&quot;;
            println(&quot;[w1] i: &quot; + i + &quot; s: &quot; + s);
            // Reply to the join block from worker w1.
            i, s -&gt; fork;
        }

        worker w2 {
            float f = 10.344;
            println(&quot;[w2] f: &quot; + f);
            // Reply to the join block from worker w2.
            f -&gt; fork;
        }

    } join (all) (map results) {
        //Here we use &quot;all&quot; as the join condition which means wait for all the workers.
        //When the join condition has been satisfied, results 'map' will be filled with
        //the returned values from the workers.

        // Get values received from worker 'w1'.
        var resW1, _ = (any[])results[&quot;w1&quot;];
        var iW1, _ = (int)resW1[0];
        var sW1, _ = (string)resW1[1];
        println(&quot;[join-block] iW1: &quot; + iW1 + &quot; sW1: &quot; + sW1);
        // Get values received from worker 'w2'.
        var resW2, _ = (any[])results[&quot;w2&quot;];
        var fW2, _ = (float)resW2[0];
        println(&quot;[join-block] fW2: &quot; + fW2);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run fork-join.bal
[w1] i: 23 s: Colombo
[w2] f: 10.344
[join-block] iW1: 23 sW1: Colombo
[join-block] fW2: 10.344
</code></pre>
<a class="header" href="print.html#forkjoin-condition-some" id="forkjoin-condition-some"><h1>Fork/Join Condition Some</h1></a>
<p>This example demonstrates the &quot;some k&quot; join condition where it waits for any k of the given workers.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {

    // Declare the fork-join statement.
    fork {
        worker w1 {
            int i = 23;
            string s = &quot;Colombo&quot;;
            println(&quot;[w1] i: &quot; + i + &quot; s: &quot; + s);
            // Reply to the join block from worker w1.
            i, s -&gt; fork;
        }

        worker w2 {
            float f = 10.344;
            println(&quot;[w2] f: &quot; + f);
            // Reply to the join block from worker w2.
            f -&gt; fork;
        }
    } join (some 1) (map results) {
        //Here we use &quot;some 1&quot; as the join condition which means wait for any one of
        //the workers.
        //When the join condition has been satisfied, results 'map' will be filled with
        //the returned values from the workers.

        // Check whether the completed worker is 'w1'.
        if (results[&quot;w1&quot;] != null) {
            var resW1, _ = (any[])results[&quot;w1&quot;];
            var iW1, _ = (int)resW1[0];
            var sW1, _ = (string)resW1[1];
            println(&quot;[join-block] iW1: &quot; + iW1 + &quot; sW1: &quot; + sW1);
        }

        // Check whether the completed worker is 'w2'.
        if (results[&quot;w2&quot;] != null) {
            var resW2, _ = (any[])results[&quot;w2&quot;];
            var fW2, _ = (float)resW2[0];
            println(&quot;[join-block] fW2: &quot; + fW2);
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run fork-join-condition-some.bal
[w2] f: 10.344
[w1] i: 23 s: Colombo
[join-block] fW2: 10.344
</code></pre>
<a class="header" href="print.html#forkjoin-variable-access" id="forkjoin-variable-access"><h1>Fork/Join Variable Access</h1></a>
<p>Workers within fork-join can access any variables which are declared within the scope of that statement.
Value type variables are passed into these workers as a copy of the original data.
Reference type variables are passed into these workers as a reference to the original data.
Join block receives a map of any type array which contains the data sent from the respective workers.</p>
<pre><pre class="playpen"><code class="language-ballerina">// In scope variables can be accessed within workers of fork-join statement.
function main (string[] args) {
    // Define variables which are visible to the forked workers.
    int i = 100;
    string s = &quot;WSO2&quot;;
    map m = {&quot;name&quot;:&quot;Abhaya&quot;, &quot;era&quot;:&quot;Anuradhapura&quot;};

    // Declare the fork-join statement.
    fork {
        worker W1 {
            // Change the value of the integer variable &quot;i&quot; within the worker W1.
            i = 23;
            // Change the value of map variable &quot;m&quot; within the worker W1.
            m[&quot;name&quot;] = &quot;Rajasinghe&quot;;
            // Define a variable within the worker to send to join block.
            string n = &quot;Colombo&quot;;
            // Send data to join block of the fork-join from worker W1.
            i, n -&gt; fork;
        }

        worker W2 {
            // Change the value of string variable &quot;s&quot; within the worker W2.
            s = &quot;Ballerina&quot;;
            // Change the value of map variable &quot;m&quot; within the worker W2.
            m[&quot;era&quot;] = &quot;Kandy&quot;;
            // Send data to join block of the fork-join from worker W2.
            s -&gt; fork;
        }
    } join (all) (map results) {
        // Declare variables to receive the results from forked workers W1 and W2.
        any[] r1;
        any[] r2;
        // The 'results' map contains a map of any type array from each worker
        // defined within the fork-join statement.
        // Values received from worker W1 are assigned to any array of r1.
        r1, _ = (any[])results[&quot;W1&quot;];
        // Values received from worker W2 are assigned to any array of r2.
        r2, _ = (any[])results[&quot;W2&quot;];
        // Getting the 0th index of array returned from worker W1.
        int p;
        p, _ = (int)r1[0];
        // Getting the 1th index of array returned from worker W1.
        string l;
        l, _ = (string)r1[1];
        // Getting the 0th index of array returned from worker W2.
        string q;
        q, _ = (string)r2[0];
        // Print values received from workers within join block.
        println(&quot;[default worker] within join:
        Value of integer from W1 is [&quot; + p + &quot;]&quot;);
        println(&quot;[default worker] within join:
        Value of string from W1 is [&quot; + l + &quot;]&quot;);
        println(&quot;[default worker] within join:
        Value of string from W2 [&quot; + q + &quot;]&quot;);
    }
    // Print values after the fork-join statement to check effect on variables.
    // Value type variables have not been changed since they are passed in as a
    // copy of the original variable.
    println(&quot;[default worker] after fork-join:
        Value of integer variable is [&quot; + i + &quot;]
        Value of string variable is [&quot; + s + &quot;]&quot;);
    // Reference type variables are changed since they have passed in as a
    // reference to the workers.
    string name;
    string era;
    name, _ = (string)m[&quot;name&quot;];
    era, _ = (string)m[&quot;era&quot;];
    println(&quot;[default worker] after fork-join:
        Value of name is [&quot; + name + &quot;]
        Value of era is [&quot; + era + &quot;]&quot;);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run fork-join-variable-access.bal
[default worker] within join:
      Value of integer from W1 is [23]
[default worker] within join:
      Value of string from W1 is [Colombo]
[default worker] within join:
      Value of string from W2 [Ballerina]
[default worker] after fork-join:
      Value of integer variable is [100]
      Value of string variable is [WSO2]
[default worker] after fork-join:
      Value of name is [Rajasinghe]
      Value of era is [Kandy]

</code></pre>
<a class="header" href="print.html#sql-connector" id="sql-connector"><h1>SQL Connector</h1></a>
<p>Ballerina SQL Connector is used to access and manipulate data in the relational databases.
This sample use MySQL DB and before running the sample copy the MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB connection properties as required.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.data.sql;

function main (string[] args) {
    endpoint&lt;sql:ClientConnector&gt; testDB {
        create sql:ClientConnector(
        sql:DB.MYSQL, &quot;localhost&quot;, 3306, &quot;testdb&quot;, &quot;root&quot;, &quot;root&quot;,
            {maximumPoolSize:5});
    }
    //Create a DB table using update action.If the DDL
    //statement execution is success update action returns 0.
    int ret = testDB.update(&quot;CREATE TABLE STUDENT(ID INT AUTO_INCREMENT, AGE INT,
                                NAME VARCHAR(255), PRIMARY KEY (ID))&quot;, null);
    println(&quot;Table creation status:&quot; + ret);

    //Create a stored procedure using update action.
    ret = testDB.update(&quot;CREATE PROCEDURE GETCOUNT (IN pAge INT, OUT pCount INT,
                         INOUT pInt INT)
                         BEGIN SELECT COUNT(*) INTO pCount FROM STUDENT
                              WHERE AGE = pAge; SELECT COUNT(*) INTO pInt FROM
                              STUDENT WHERE ID = pInt;
                         END&quot;, null);
    println(&quot;Stored proc creation status:&quot; + ret);

    //Insert data using update action. If the DML statement execution
    //is success update action returns the updated row count.
    sql:Parameter[] params = [];
    sql:Parameter para1 = {sqlType:sql:Type.INTEGER, value:8};
    sql:Parameter para2 = {sqlType:sql:Type.VARCHAR, value:&quot;Sam&quot;};
    params = [para1, para2];
    ret = testDB.update(&quot;INSERT INTO STUDENT (AGE,NAME) VALUES (?,?)&quot;, params);
    println(&quot;Inserted row count:&quot; + ret);

    //Column values generated during the update can be retrieved via
    //updateWithGeneratedKeys action. If the table has several auto
    //generated columns other than the auto incremented key, those column
    //names should be given as an array. The values of the auto incremented
    //column and the auto generated columns are returned as string array.
    //Similar to the update action, the inserted row count is also returned.
    var count, ids = testDB.updateWithGeneratedKeys(&quot;INSERT INTO STUDENT
                      (AGE,NAME) VALUES (?, ?)&quot;, params, null);
    println(&quot;Inserted row count:&quot; + count);
    println(&quot;Generated key:&quot; + ids[0]);

    //Select data using select action. Select action returns a datatable
    //and see datatables section for more details on how to access data.
    params = [para1];
    datatable dt = testDB.select(&quot;SELECT * FROM STUDENT WHERE AGE = ?&quot;, params);
    var jsonRes, err = &lt;json&gt;dt;
    println(jsonRes);

    //A Batch of data can be inserted using  batchUpdate action. Number
    //of inserted rows for each insert in the batch is returned as an array.
    sql:Parameter p1 = {sqlType:sql:Type.INTEGER, value:10};
    sql:Parameter p2 = {sqlType:sql:Type.VARCHAR, value:&quot;Smith&quot;};
    sql:Parameter[] item1 = [p1, p2];
    sql:Parameter p3 = {sqlType:sql:Type.INTEGER, value:20};
    sql:Parameter p4 = {sqlType:sql:Type.VARCHAR, value:&quot;John&quot;};
    sql:Parameter[] item2 = [p3, p4];
    sql:Parameter[][] bPara = [item1, item2];
    int[] c = testDB.batchUpdate(&quot;INSERT INTO STUDENT (AGE,NAME) VALUES (?, ?)&quot;,bPara);
    println(&quot;Batch item 1 status:&quot; + c[0]);
    println(&quot;Batch item 2 status:&quot; + c[1]);

    //A stored procedure can be invoked via call action. The direction is
    //used to specify in/out/inout parameters.
    sql:Parameter pAge = {sqlType:sql:Type.INTEGER, value:10};
    sql:Parameter pCount = {sqlType:sql:Type.INTEGER, direction: sql:Direction.IN};
    sql:Parameter pId = {sqlType:sql:Type.INTEGER, value:1, direction:
                                                            sql:Direction.OUT};
    params = [pAge, pCount, pId];
    var results = testDB.call(&quot;{CALL GETCOUNT(?,?,?)}&quot;, params);
    var countValue, _ = (int)pCount.value;
    println(&quot;Age 10 count:&quot; + countValue);
    var idValue, _ = (int)pId.value;
    println(&quot;Id 1 count:&quot; + idValue);

    //Drop the STUDENT table.
    ret = testDB.update(&quot;DROP TABLE STUDENT&quot;, null);
    println(&quot;Table drop status:&quot; + ret);

    //Drop the GETCOUNT procedure.
    ret = testDB.update(&quot;DROP PROCEDURE GETCOUNT&quot;, null);
    println(&quot;Procedure drop status:&quot; + ret);

    //Finally close the connection pool.
    testDB.close();
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run sql-connector.bal
Table creation status:0
Stored proc creation status:0
Inserted row count:1
Inserted row count:1
Generated key:2
[{&quot;ID&quot;:1,&quot;AGE&quot;:8,&quot;NAME&quot;:&quot;Sam&quot;},{&quot;ID&quot;:2,&quot;AGE&quot;:8,&quot;NAME&quot;:&quot;Sam&quot;}]
Batch item 1 status:1
Batch item 2 status:1
Age 10 count:1
Id 1 count:1
Table drop status:0
Procedure drop status:0
</code></pre>
<a class="header" href="print.html#datatables" id="datatables"><h1>Datatables</h1></a>
<p>The datatable type is used to hold tabular data, such as those returned from an SQL database query and provides cursor based access to the data.
This sample use MySQL DB and before running the sample copy the MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB connection properties as required.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.data.sql;

//This is the Employee struct. The field names of this should match column names
//of the table. The field types should match with the sql types.
struct Employee {
    int id;
    string name;
    float salary;
    boolean status;
    string birthdate;
    string birthtime;
    string updated;
}

function main (string[] args) {
    endpoint&lt;sql:ClientConnector&gt; testDB {
      create sql:ClientConnector(
        sql:DB.MYSQL, &quot;localhost&quot;, 3306, &quot;testdb&quot;, &quot;root&quot;, &quot;root&quot;,
            {maximumPoolSize:5});
    }

    //Create table named EMPLOYEE and populate sample data.
    int count = testDB.update(&quot;CREATE TABLE EMPLOYEE (id INT,name
        VARCHAR(25),salary DOUBLE,status BOOLEAN,birthdate DATE,birthtime TIME,
        updated TIMESTAMP)&quot;, null);
    count = testDB.update(&quot;INSERT INTO EMPLOYEE VALUES(1, 'John', 1050.50, false,
        '1990-12-31', '11:30:45', '2007-05-23 09:15:28')&quot;, null);
    count = testDB.update(&quot;INSERT INTO EMPLOYEE VALUES(2, 'Anne', 4060.50, true,
        '1999-12-31', '13:40:24', '2017-05-23 09:15:28')&quot;, null);

    //Query the table using SQL connector select action. Either select or call
    //action can return a datatable.
    datatable dt = testDB.select(&quot;SELECT * from EMPLOYEE&quot;, null);
    //Iterate through the result until hasNext() become false and retrieve
    //the data struct corresponding to each row.
    while (dt.hasNext()) {
        var rs, _ = (Employee)dt.getNext();
        println(&quot;Employee:&quot;+ rs.id + &quot;|&quot; + rs.name +  &quot;|&quot; + rs.salary + &quot;|&quot; + rs.status
                + &quot;|&quot; + rs.birthdate + &quot;|&quot; + rs.birthtime + &quot;|&quot; + rs.updated);
    }

    //Convert a datatable to JSON.
    dt = testDB.select(&quot;SELECT id,name FROM EMPLOYEE&quot;, null);
    var jsonRes, _ = &lt;json&gt;dt;
    println(jsonRes);

    //Convert a datatable to XML.
    dt = testDB.select(&quot;SELECT id,name FROM EMPLOYEE&quot;, null);
    var xmlRes, _ = &lt;xml&gt;dt;
    println(xmlRes);

    //Drop the EMPLOYEE table.
    int ret = testDB.update(&quot;DROP TABLE EMPLOYEE&quot;, null);
    println(&quot;Table drop status:&quot; + ret);

    //Finally close the DB connection.
    testDB.close();
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run datatables.bal
Employee:1|John|1050.5|false|1990-12-31+05:30|11:30:45.000+05:30|2007-05-23T09:15:
28.000+05:30
Employee:2|Anne|4060.5|true|1999-12-31+06:00|13:40:24.000+05:30|2017-05-23T09:15:
28.000+05:30
[{&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;Anne&quot;}]
&lt;results&gt;&lt;result&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;John&lt;/name&gt;&lt;/result&gt;&lt;result&gt;&lt;id&gt;2&lt;/id&gt;&lt;name&gt;Anne
&lt;/name&gt;&lt;/result&gt;&lt;/results&gt;
Table drop status:0
</code></pre>
<a class="header" href="print.html#transactions" id="transactions"><h1>Transactions</h1></a>
<p>Ballerina transaction is a series of data manipulation  statements that must either fully complete or fully fail,  leaving the system in a consistent state.
This sample use MySQL DB and before running the sample copy the MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB connection properties as required.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.data.sql;

function main (string[] args) {
    endpoint&lt;sql:ClientConnector&gt; testDB {
      create sql:ClientConnector(
        sql:DB.MYSQL, &quot;localhost&quot;, 3306, &quot;testdb&quot;, &quot;root&quot;, &quot;root&quot;,
            {maximumPoolSize:5});
    }
    //Create the tables required for the transaction.
    int updatedRows = testDB.update(&quot;CREATE TABLE IF NOT EXISTS CUSTOMER (ID INT,
        NAME VARCHAR(30))&quot;, null);
    updatedRows = testDB.update(&quot;CREATE TABLE IF NOT EXISTS SALARY (ID INT,
        MON_SALARY FLOAT)&quot;, null);
    //Here is the transaction block. You can use a Try catch here since update action
    //can throw errors due to SQL errors, connection pool errors etc.
    transaction {
        //This is the first action participate in the transaction.
        int c = testDB.update(&quot;INSERT INTO CUSTOMER(ID,NAME) VALUES (1, 'Anne')&quot;,
                              null);
        //This is the second action participate in the transaction.
        c = testDB.update(&quot;INSERT INTO SALARY (ID, MON_SALARY) VALUES (1, 2500)&quot;,
                          null);

        println(&quot;Inserted count:&quot; + c);
        //Anytime the transaction can be forcefully aborted using the abort keyword.
        if (c == 0) {
            abort;
        }
        //The end curly bracket marks the end of the transaction and the transaction
        //will be committed or rolled back at this point.
    } failed {
        //The failed block will be executed if the transaction is failed due to an
        //exception or a throw statement. This block will execute each time
        //transaction is failed until retry count is reached.
        println(&quot;Transaction failed&quot;);
        //The retry count is the number of times the transaction is tried before
        //aborting. By default a transaction is tried three times before aborting.
        //Only integer literals or constants are allowed for retry count.
        retry 4;
    } aborted {
        //The aborted block will be executed if the transaction is aborted using an
        //abort statement or failed even after retrying the specified count.
        println(&quot;Transaction aborted&quot;);
    } committed {
        //The committed block will be executed if the transaction
        //is successfully committed.
        println(&quot;Transaction committed&quot;);
    }
    //Close the connection pool.
    testDB.close();
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run transactions.bal
Inserted count:1
Transaction committed
</code></pre>
<a class="header" href="print.html#transformers" id="transformers"><h1>Transformers</h1></a>
<p>Transformers are used to convert a variable of one type to another. Additional arguments can also be passed to a transformer for the conversion.
The transformer can be defined as a high level construct, and can be used within any expression using the type conversion syntax.</p>
<pre><pre class="playpen"><code class="language-ballerina">//Defining Employee struct.
struct Employee {
    string name;
    int age;
    string address;
}

//Defining Person struct.
struct Person {
    string firstName;
    string lastName;
    int age;
    string city;
    string street;
}

//Defining a default transformer for converting from 'Person' type to 'Employee' type.
transformer &lt;Person p, Employee e&gt; {
    e.name = p.firstName + &quot; &quot; + p.lastName;
    e.age = p.age;
    e.address = p.street + &quot;,&quot; + p.city.toUpperCase();
}

//Defining a named transformer for converting from 'Person' type to 'Employee' type.
transformer &lt;Person p, Employee e&gt; setCityToNewYork() {
    e.name = p.firstName + &quot; &quot; + p.lastName;
    e.age = p.age;
    e.address = p.street + &quot;, &quot; + &quot;New York&quot;;
}

//Defining a named transformer which takes input parameters for converting from
//'Person' type to 'Employee' type.
transformer &lt;Person p, Employee e&gt; insertCountry(string country) {
    e.name = p.firstName + &quot; &quot; + p.lastName;
    e.age = p.age;
    e.address = p.street + &quot;,&quot; + p.city.toUpperCase() + &quot;, &quot; + country;
}

function main (string[] args) {
    //Initialize Person variable person.
    Person person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:30, city:&quot;London&quot;};

    //Using default transformer to convert from type Person to Employee is similar
    //to the conversion syntax.
    Employee employee = &lt;Employee&gt;person;
    println(employee);

    //Named transformer can be explicitly provided inside the conversion syntax, to
    //convert person to employee.
    employee = &lt;Employee, setCityToNewYork()&gt;person;
    println(employee);

    //Using the named transformer to convert person to employee, by passing parameters.
    employee = &lt;Employee, insertCountry(&quot;UK&quot;)&gt;person;
    println(employee);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run transformers.bal
{name:&quot;john&quot;, age:30, address:&quot;london&quot;}
{name:&quot;john&quot;, age:32, address:&quot;LONDON&quot;}
{name:&quot;john&quot;, age:30, address:&quot;london, UK&quot;}
</code></pre>
<a class="header" href="print.html#transform-json" id="transform-json"><h1>Transform JSON</h1></a>
<p>Transformers are used to convert a variable of one type to another. This sample is about defining and using a custom transformer to convert struct variable to an output 'json' variable which is constraint by a struct type.</p>
<pre><pre class="playpen"><code class="language-ballerina">//Defining Person struct.
struct Person {
    string name;
    int age;
    string city;
}

//Defining transformer to convert from Person type to constrained JSON.
transformer &lt;Person p, json&lt;Person&gt; j&gt; updateCity(string city) {
    j.name = p.name;
    j.age = p.age;
    j.city = city;
}


function main (string[] args) {
    json j = {&quot;name&quot;:&quot;Ann&quot;, &quot;age&quot;: 30 ,&quot;city&quot;:&quot;New York&quot;};

    //Declare a Person variable.
    Person p;

    //Declare a type conversion error to accept any type conversion errors thrown.
    TypeConversionError err;
    //Convert JSON to a Person type variable.
    p, err = &lt;Person&gt;j;

    //Print if an error is thrown.
    if (err != null) {
        println(err);
    }

    //Define a constant city value as &quot;London&quot;.
    string city = &quot;London&quot;;

    //Convert p of type Person to the response JSON, using the transformer
    //defined earlier.
    json&lt;Person&gt; response = &lt;json&lt;Person&gt;, updateCity(city)&gt; p;

    println(response);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run transform-json.bal
{&quot;name&quot;:&quot;Ann&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;London&quot;}
</code></pre>
<a class="header" href="print.html#strings" id="strings"><h1>Strings</h1></a>
<p>Ballerina contains a comprehensive set of string manipulation functions.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {

    string statement = &quot;Lion in Town. Catch the Lion &quot;;

    string s1 = statement.toUpperCase();
    println(&quot;ToUpper: &quot; + s1);

    string s2 = statement.toLowerCase();
    println(&quot;ToLower: &quot; + s2);

    //Compares two strings, ignoring the case. Returns True if the strings are equal;
    //false otherwise.
    boolean isEqual = statement.equalsIgnoreCase(&quot;lion in town. catch the lion &quot;);
    println(&quot;EqualsIgnoreCase: &quot; + isEqual);

    //Returns a new string that is the substring of the specified string. The original
    //string, starting index and
    //ending index should be specified.
    string s3 = statement.subString(0, 4);
    println(&quot;SubString: &quot; + s3);

    boolean contains = statement.contains(&quot;Lion&quot;);
    println(&quot;Contains: &quot; + contains);

    //Returns the first index of the first occurrence of the substring within the
    //specified string.
    int index = statement.indexOf(&quot;on&quot;);
    println(&quot;IndexOf: &quot; + index);

    //Returns the first index of the last occurrence of the substring within the
    //specified string.
    int lastIndex = statement.lastIndexOf(&quot;on&quot;);
    println(&quot;LastIndexOf: &quot; + lastIndex);

    //Converts a float type into a string.
    float value = 5.8;
    string s4 = &lt;string&gt;value;
    println(&quot;ValueOf: &quot; + s4);

    //Replaces the first instance of the replacePattern with the replaceWith string.
    string s5 = statement.replaceFirst(&quot;Lion&quot;, &quot;Tiger&quot;);
    println(&quot;ReplaceFirst: &quot; + s5);

    //This replaces the replacePattern string with the replacement string.
    string s6 = statement.replace(&quot;Lion&quot;, &quot;Tiger&quot;);
    println(&quot;Replace: &quot; + s6);

    //Replaces each substring of the replacePattern that matches the given regular
    //expression with the replacement string.
    string s7 = statement.replaceAll(&quot;[o]+&quot;, &quot;0&quot;);
    println(&quot;ReplaceAll: &quot; + s7);

    //Returns the length of the string.
    int length = statement.length();
    println(&quot;Length: &quot; + length);

    //Remove any leading and trailing white spaces
    string s8 = statement.trim();
    println(&quot;Trim: &quot; + s8);

    //Tests if this string ends with the specified suffix.
    boolean hasSuffix = statement.hasSuffix(&quot;Lion &quot;);
    println(&quot;HasSuffix: &quot; + hasSuffix);

    //Tests if this string starts with the specified prefix.
    boolean hasPrefix = statement.hasPrefix(&quot;Lion&quot;);
    println(&quot;HasPreffix: &quot; + hasPrefix);

    //Returns an unescaped string by omitting the escape characters of the original
    //string.
    string s9 = statement.unescape();
    println(&quot;Unescape: &quot; + s9);

    //Splits the string with the given regular expression to produce a string array.
    string[] array = statement.split(&quot; &quot;);
    println(&quot;Split: &quot; + array[0]);
    println(&quot;Split: &quot; + array[1]);
    println(&quot;Split: &quot; + array[2]);

    //Converts string to a BLOB.
    blob blobValue = statement.toBlob(&quot;UTF-8&quot;);

    //Converts the BLOB to the string.
    string s10 = blobValue.toString(&quot;UTF-8&quot;);
    println(&quot;Blob: &quot; + s10);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run strings.bal
ToUpper: LION IN TOWN. CATCH THE LION
ToLower: lion in town. catch the lion
EqualsIgnoreCase: true
SubString: Lion
Contains: true
IndexOf: 2
LastIndexOf: 26
ValueOf: 5.8
ReplaceFirst: Tiger in Town. Catch the Lion
Replace: Tiger in Town. Catch the Tiger
ReplaceAll: Li0n in T0wn. Catch the Li0n
Length: 29
Trim: Lion in Town. Catch the Lion
HasSuffix: true
HasPreffix: true
Unescape: Lion in Town. Catch the Lion
Split: Lion
Split: in
Split: Town.
Blob: Lion in Town. Catch the Lion
</code></pre>
<a class="header" href="print.html#blob-type" id="blob-type"><h1>Blob Type</h1></a>
<p>The 'blob' type represents a sequence of bytes. It is a value type in Ballerina.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Convert a string value to blob by providing the encoding to be used.
    string text = &quot;Sample Text&quot;;
    blob content = text.toBlob(&quot;UTF-8&quot;);

    //Convert a blob value into a string value by providing the encoding.
    string str = content.toString(&quot;UTF-8&quot;);
    println(str);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run blob-type.bal
Sample Text
</code></pre>
<a class="header" href="print.html#date-time" id="date-time"><h1>Date Time</h1></a>
<p>Ballerina Date time API is used to manipulate date and time related data.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    //Time struct can be created by currentTime, createTime or parse functions.
    //Get the current time.
    Time time = currentTime();
    int currentTimeMills = time.time;
    println(&quot;Current system time in milliseconds: &quot; + currentTimeMills);
    //Create a time with the required year, month ,date,
    //time and zone information.
    Time timeCreated = createTime(2017, 3, 28, 23, 42, 45, 554, &quot;America/Panama&quot;);
    println(&quot;Created Time: &quot; + timeCreated.toString());
    //Returns the time for the given string representation
    //based on the given format string.
    Time t1 = parse(&quot;2017-06-26T09:46:22.444-0500&quot;, &quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;);
    println(&quot;Parsed Time: &quot; + t1.toString());
    //String representation of time can be retrieved via toString or format
    //functions.Get the ISO 8601 formatted string of a given time.
    string standardTimeString = time.toString();
    println(&quot;Current system time in ISO format: &quot; + standardTimeString);
    //Get the formatted string of a given time.
    string customTimeString = time.format(&quot;yyyy-MM-dd-E&quot;);
    println(&quot;Current system time in custom format: &quot; + customTimeString);
    //Information of time can be retrieved via following
    //functions.Get the year of a given time.
    int year = time.year();
    println(&quot;Year: &quot; + year);
    //Get the month of a given time.
    int month = time.month();
    println(&quot;Month: &quot; + month);
    //Get the day of a given time.
    int day = time.day();
    println(&quot;Day: &quot; + day);
    //Get the hour of a given time.
    int hour = time.hour();
    println(&quot;Hour: &quot; + hour);
    //Get the minute of a given time.
    int minute = time.minute();
    println(&quot;Minute: &quot; + minute);
    //Get the second of a given time.
    int second = time.second();
    println(&quot;Second: &quot; + second);
    //Get the milli second of a given time.
    int milliSecond = time.milliSecond();
    println(&quot;Millisecond: &quot; + milliSecond);
    //Get the week day of a given time.
    string weekday = time.weekday();
    println(&quot;Weekday: &quot; + weekday);
    //Get date components of time using a single function.
    year, month, day = time.getDate();
    println(&quot;Date: &quot; + year + &quot;:&quot; + month + &quot;:&quot; + day);
    //Get time components using a single function.
    hour, minute, second, milliSecond = time.getTime();
    println(&quot;Time:&quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;:&quot; + milliSecond);
    //Add a given duration to the time. Here we are adding
    //one year, one month and one second to the current time.
    Time tmAdd = time.addDuration(1, 1, 0, 0, 0, 1, 0);
    println(&quot;After add duration: &quot; + tmAdd.toString());
    //Subtract a given duration from the time. Here we are subtracting one year,
    //one month and one second from the current time.
    Time tmSub = time.subtractDuration(1, 1, 0, 0, 0, 1, 0);
    println(&quot;After subtract duration: &quot; + tmSub.toString());
    //Convert to a different time zone.
    Time t2 = createTime(2017, 3, 28, 23, 42, 45, 554, &quot;America/Panama&quot;);
    println(&quot;Before convert zone: &quot; + t2.toString());
    Time t3 = t2.toTimezone(&quot;Asia/Colombo&quot;);
    println(&quot;After convert zone:&quot; + t3.toString());
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run date-time.bal
Current system time in milliseconds: 1509122456117
Created Time: 2017-03-28T23:42:45.554-05:00
Parsed Time: 2017-06-26T09:46:22.444-05:00
Current system time in ISO format: 2017-10-27T22:10:56.117+05:30
Current system time in custom format: 2017-10-27-Fri
Year: 2017
Month: 10
Day: 27
Hour: 22
Minute: 10
Second: 56
Millisecond: 117
Weekday: FRIDAY
Date: 2017:10:27
Time:22:10:56:117
After add duration: 2018-11-27T22:10:57.117+05:30
After subtract duration: 2016-09-27T22:10:55.117+05:30
Before convert zone: 2017-03-28T23:42:45.554-05:00
After convert zone:2017-03-29T10:12:45.554+05:30
</code></pre>
<a class="header" href="print.html#file-api" id="file-api"><h1>File API</h1></a>
<p>The 'ballerina.file' package contains basic file handling functions.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.file;

function main (string[] args) {
    //Create 'File' struct and open for writing.
    file:File target = {path:&quot;/tmp/result.txt&quot;};
    target.open(file:W);

    //Close the file once done.
    target.close();

    //Check whether the file exists.
    boolean b = target.exists();
    println(&quot;file exists: &quot; + b);

    //Here's how you can copy a file.
    file:File source = {path:&quot;/tmp/result.txt&quot;};
    file:File destination = {path:&quot;/tmp/copy.txt&quot;};
    file:copy(source, destination);
    println(&quot;file copied: /tmp/result.txt to /tmp/copy.txt&quot;);

    //How to delete a file.
    destination.delete();
    println(&quot;file deleted: /tmp/copy.txt&quot;);

    //Move source file to destination.
    destination = {path:&quot;/tmp/move.txt&quot;};
    file:move(source, destination);
    println(&quot;file moved: /tmp/result.txt to /tmp/move.txt&quot;);

    destination.delete();
    println(&quot;file deleted: /tmp/move.txt&quot;);

    //Create a directory, along with the parent directories.
    file:File dirs = {path:&quot;/tmp/dir/abc/def&quot;};
    var dirCreated, _, _ = dirs.mkdirs();

    //Check if a file is a directory.
    file:File possibleDir = {path:&quot;/tmp/dir/abc&quot;};
    println(&quot;file is a directory: &quot; + possibleDir.isDirectory());

    //Create new files inside a directory (ignoring all 3 possible return values).
    file:File newFile1 = {path:&quot;/tmp/dir/abc/file1.txt&quot;};
    _,_,_ = newFile1.createNewFile();

    file:File newFile2 = {path:&quot;/tmp/dir/abc/file2.txt&quot;};
    _,_,_ = newFile2.createNewFile();

    file:File newFile3 = {path:&quot;/tmp/dir/abc/file3.txt&quot;};
    _,_,_ = newFile3.createNewFile();

    //Get the list of files in a directory.
    var filesList, _, _ = possibleDir.list();

    //Print the list of files in directory &quot;/tmp/dir/abc&quot;.
    int i=0;
    while (i &lt; lengthof filesList) {
        println(filesList[i]);
        i = i + 1;
    }

    //Get file meta data.
    string name = newFile1.getName();
    Time lastModifiedTime;
    lastModifiedTime, _, _ = newFile1.getModifiedTime();
    println(name + &quot; modified at: &quot; + lastModifiedTime.time);
    println(name + &quot; is readable: &quot; + newFile1.isReadable());
    println(name + &quot; is writable: &quot; + newFile1.isWritable());
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run file-api.bal
file exists: true
file copied: /tmp/result.txt to /tmp/copy.txt
file deleted: /tmp/copy.txt
file moved: /tmp/result.txt to /tmp/move.txt
file deleted: /tmp/move.txt
file is a directory: true
{path:&quot;/tmp/dir/abc/file3.txt&quot;}
{path:&quot;/tmp/dir/abc/file2.txt&quot;}
{path:&quot;/tmp/dir/abc/file1.txt&quot;}
{path:&quot;/tmp/dir/abc/def&quot;}
file1.txt modified at: 1509125400000
file1.txt is readable: true
file1.txt is writable: true
</code></pre>
<a class="header" href="print.html#throw" id="throw"><h1>Throw</h1></a>
<p>In Ballerina, throwing an error means, something unexpected has happened that shouldn’t occur during the normal operation. A thrown error causes the call stack to be unwound until a matching catcher is found.</p>
<p>Ballerina encourages developers, NOT to use 'throw' for handling program related errors (i.e header not found, Data mismatched error etc), but in an error situation where it couldn't handle the error by itself, like accessing a Null Reference, Connection Closed/TimeOut and OutOfMemory etc.</p>
<pre><pre class="playpen"><code class="language-ballerina">struct Record {
    int id;
    string name;
}

//Here's how you can throw an error. Next example shows you how to catch thrown errors.
function readRecord (Record value) {
    if (value == null) {
        error err = {msg:&quot;Record is null&quot;};
        throw err;
    }
    println(&quot;Record ID: &quot; + value.id + &quot;, value: &quot; + value.name);
}

function main (string[] args) {
    Record r1 = {id:1, name:&quot;record1&quot;};
    readRecord(r1);
    Record r2;
    // Record r2 is null.
    readRecord(r2);
    // Following lines will not execute.
    Record r3 = {id:3, name:&quot;record3&quot;};
    readRecord(r3);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run throw.bal
Record ID: 1, value: record1
error: error, message: record is null
    at .:readRecord(throw.bal:10)
    at .:main(throw.bal:20)
</code></pre>
<a class="header" href="print.html#trycatchfinally" id="trycatchfinally"><h1>Try/Catch/Finally</h1></a>
<p>Throwing an error generally means an unexpected error has happend, and the code that handles the thrown error is not expected to be able to do much to recover from it, rather than perhaps catch and log it.</p>
<p>Throwing errors will be very rare and will happen under exceptional circumstances such as server going out of memory, running out of disk space.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    string[] texts = null;
    //Use a try block to surrounds a code segment that an error may occur.
    try {
        println(&quot;start Accessing texts&quot;);
        //Accessing a null variable 'texts' causes a NullReferenceError to be thrown.
        string value = texts[0];
        println(value);
        //A Catch block executes, when an error is thrown from the enclosing try
        //block and the thrown error type and catch clause's error type are matched, or
        //if there is no match, then the catch is the first in the order, where thrown
        //error type and catch clause's error type are structurally equivalent.
    } catch (error err) {
        println(&quot;error occured: &quot; + err.msg);
    //Catching specific error type 'NullReferenceException'.
    } catch (NullReferenceException err) {
        println(&quot;NullReferenceException error occurred&quot;);
    } finally {
        println(&quot;finally Block executed&quot;);
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run try-catch-finally.bal
start Accessing texts
NullReferenceError error occurred
finally Block executed
</code></pre>
<a class="header" href="print.html#base-path-and-path" id="base-path-and-path"><h1>Base Path and Path</h1></a>
<p>Ballerina support writing RESTFul services according to JAX-RS specification.
BasePath, Path and HTTP verb annotations such as POST, GET, etc can be used to constrain your service in RESTful manner.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

//BasePath attribute associates a path to the service.
@http:configuration {basePath:&quot;/foo&quot;}
service&lt;http&gt; echo {
    //Post annotation constrains the resource only to accept post requests.
    //Similarly, for each HTTP verb there are different annotations.
    //Path attribute associates a sub-path to resource.
    @http:resourceConfig {
        methods:[&quot;POST&quot;],
        path:&quot;/bar&quot;
    }
    resource echo (http:Request req, http:Response res) {
        //A util method that can get the request payload.
        json payload = req.getJsonPayload();
        res.setJsonPayload(payload);
        //Send back the response to the client.
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run base-path-and-path.bal
ballerina: deploying service(s) in '.../base-path-and-path.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl http://localhost:9090/foo/bar -d &quot;{\&quot;hello\&quot;: \&quot;world\&quot;}&quot; -H 
&quot;Content-Type: application/json&quot;
{&quot;hello&quot;: &quot;world&quot;}
</code></pre>
<a class="header" href="print.html#query-and-path-param" id="query-and-path-param"><h1>Query and Path Param</h1></a>
<p>Ballerina support extracting values both from PathParam and QueryParam.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

service&lt;http&gt; sample {

    @http:resourceConfig {
        methods:[&quot;GET&quot;],
        path:&quot;/path/{foo}&quot;
    }
    // PathParam and QueryParam extract values from the request URI.
    resource params (http:Request req, http:Response res, string foo) {
        // Get QueryParam.
        map params = req.getQueryParams();
        var bar, _ = (string)params.bar;
        // Create json payload with the extracted values.
        json responseJson = {&quot;pathParam&quot;:foo, &quot;queryParam&quot;:bar};
        // A util method to set the json payload to the response message.
        res.setJsonPayload(responseJson);
        // Send a response to the client.
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run query-and-path-param.bal
ballerina: deploying service(s) in '.../query-and-path-param.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl http://localhost:9090/sample/path/value1?bar=value2
{&quot;pathParam&quot;: &quot;value1&quot;, &quot;queryParam&quot;: &quot;value2&quot;}
</code></pre>
<a class="header" href="print.html#content-based-routing" id="content-based-routing"><h1>Content Based Routing</h1></a>
<p>The Content-Based Router service reads the content of a request and routes it to a specific recipient based on its content.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

@http:configuration {basePath:&quot;/cbr&quot;}
service&lt;http&gt; contentBasedRouting {
    // http:POST{} annotation declares the HTTP method.
    @http:resourceConfig {
        methods:[&quot;POST&quot;],
        path:&quot;/route&quot;
    }
    resource cbrResource (http:Request req, http:Response res) {
        endpoint&lt;http:HttpClient&gt; locationEP {
            create http:HttpClient(&quot;http://www.mocky.io&quot;, {});
        }
        //Get JSON payload from the request message.
        json jsonMsg = req.getJsonPayload();
        //Get the string value relevant to the key &quot;name&quot;.
        string nameString;
        nameString, _ = (string)jsonMsg[&quot;name&quot;];
        http:Response clientResponse;
        http:HttpConnectorError err;
        if (nameString == &quot;sanFrancisco&quot;) {
            //&quot;post&quot; represent the POST action of HTTP connector. Route payload
            //to relevant service as the server accept the entity enclosed.
            clientResponse, err = locationEP.post(&quot;/v2/594e018c1100002811d6d39a&quot;, {});
        } else {
            clientResponse, err = locationEP.post(&quot;/v2/594e026c1100004011d6d39c&quot;, {});
        }
        //Native function &quot;forward&quot; sends back the clientResponse to the caller.
        if (err != null) {
            res.setStatusCode(500);
            res.setStringPayload(err.msg);
            _ = res.send();
        } else {
            _ = res.forward(clientResponse);
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run content-based-routing.bal
ballerina: deploying service(s) in 'content-based-routing.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl -v http://localhost:9090/cbr/route -d '{&quot;name&quot; : &quot;sanFrancisco&quot;}'
{
    &quot;name&quot;: &quot;San Francisco Test Station,USA&quot;,
    &quot;longitude&quot;: -122.43,
    &quot;latitude&quot;: 37.76,
    &quot;altitude&quot;: 150,
    &quot;rank&quot;: 1
}

$ curl -v http://localhost:9090/cbr/route -d '{&quot;name&quot; : &quot;london&quot;}'
{
    &quot;name&quot;: &quot;London Test Station,England&quot;,
    &quot;longitude&quot;: -156.49,
    &quot;latitude&quot;: 57.76,
    &quot;altitude&quot;: 430,
    &quot;rank&quot;: 5
}
</code></pre>
<a class="header" href="print.html#header-based-routing" id="header-based-routing"><h1>Header Based Routing</h1></a>
<p>The Header-Based Router service reads a particular Header of a request and routes it to a specific recipient based on the Header value.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;
// Service is invoke using BasePath value (/hbr).&quot;}
@http:configuration {basePath:&quot;/hbr&quot;}
service&lt;http&gt; headerBasedRouting {
    // The http:resourceConfig{} annotation with GET method declares the HTTP method.&quot;}
    @http:resourceConfig {
        methods:[&quot;GET&quot;],
        path:&quot;/route&quot;
    }
    resource hbrResource (http:Request req, http:Response res) {
        endpoint&lt;http:HttpClient&gt; locationEP {
            create http:HttpClient(&quot;http://www.mocky.io&quot;, {});
        }
        endpoint&lt;http:HttpClient&gt; weatherEP {
            create http:HttpClient(&quot;http://samples.openweathermap.org&quot;, {});
        }
        //Create new request and response to handle client call.
        http:Request newRequest = {};
        http:Response clientResponse = {};
        http:HttpConnectorError err;
        //Native function getHeader() returns header value of a specified header name.
        string nameString = req.getHeader(&quot;type&quot;);
        if (nameString == &quot;location&quot;) {
            //&quot;post&quot; represent the POST action of HTTP connector. Route payload to
            //relevant service.
            clientResponse, err = locationEP.post(&quot;/v2/594e12271100001f13d6d3a6&quot;,
                                                  newRequest);
        } else {
            //&quot;get&quot; action can be used to make http GET call.
            clientResponse, err = weatherEP.get(&quot;/data/2.5/weather?lat=35&amp;lon=139&amp;
                                                    appid=b1b1&quot;, newRequest);
        }
        //Native function &quot;forward&quot; sends back the clientResponse to the caller if
        //no any error is found.
        if (err != null) {
            res.setStatusCode(500);
            res.setStringPayload(err.msg);
            _ = res.send();
        } else {
            _ = res.forward(clientResponse);
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run header-based-routing.bal
ballerina: deploying service(s) in 'header-based-routing.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl -v http://localhost:9090/hbr/route -H &quot;type:location&quot;
{
    &quot;name&quot;: &quot;Colombo,Sri Lanka&quot;,
    &quot;longitude&quot;: -556.49,
    &quot;latitude&quot;: 257.76,
    &quot;altitude&quot;: 230,
}
</code></pre>
<pre><code class="language-bash">$ curl -v http://localhost:9090/hbr/route -H &quot;type:weather&quot;
{&quot;coord&quot;:{&quot;lon&quot;:139.01,&quot;lat&quot;:35.02},&quot;weather&quot;:[{&quot;id&quot;:800,
&quot;main&quot;:&quot;Clear&quot;,&quot;description&quot;:&quot;clear sky&quot;,&quot;icon&quot;:&quot;01n&quot;}],
&quot;base&quot;:&quot;station&quot;,&quot;main&quot;:{&quot;temp&quot;:25.51,&quot;clouds&quot;:{&quot;all&quot;:0},
&quot;wind&quot;:{&quot;speed&quot;:5.52,&quot;deg&quot;:311},&quot;dt&quot;:148579296788555885,
&quot;id&quot;:1907296,&quot;name&quot;:&quot;Tawarano&quot;,&quot;cod&quot;:200}}
</code></pre>
<a class="header" href="print.html#producesconsumes" id="producesconsumes"><h1>Produces/Consumes</h1></a>
<p>The sample explains the behaviour of the Consumes and Produces annotation attributes of resourceConfig in ballerina.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

//Consumes and Produces annotations contain MIME types as an array of strings.
service&lt;http&gt; infoService {

    @http:resourceConfig {
        methods:[&quot;POST&quot;],
        path:&quot;/&quot;,
        consumes:[&quot;text/json&quot;, &quot;application/json&quot;],
        produces:[&quot;application/xml&quot;]
    }
    //Resource can consume/accept text/json and application/json media types only.
    //Therefore Content-Type header must have one of the types.
    //Resource can produce application/xml payloads. Therefore Accept header should be
    //set accordingly.
    resource student (http:Request req, http:Response res) {
        //Get JSON payload from the request message.
        json jsonMsg = req.getJsonPayload();
        //Get the string value relevant to the key &quot;name&quot;.
        string nameString;
        nameString, _ = (string)jsonMsg[&quot;name&quot;];
        //Create XML payload and respond back.
        string payload = &quot;&lt;name&gt;&quot; + nameString + &quot;&lt;/name&gt;&quot;;
        var name, _ = &lt;xml&gt;payload;
        res.setXmlPayload(name);
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash"># To run the service, put the code in `produces-consumes.bal`
# and use `$BALLERINA_HOME/bin`.
$ ballerina run produces-consumes.bal
#Service deployment:
ballerina: deploying service(s) in 'produces-consumes.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash"># To invoke the service, use following client.
$ curl -v http://localhost:9090/infoService -H &quot;Accept:application/xml&quot; -H 
&quot;Content-Type:application/json&quot; -d '{&quot;name&quot;:&quot;Ballerina&quot;}'
# Server response:
&lt;name&gt;Ballerina&lt;/name&gt;
</code></pre>
<a class="header" href="print.html#http-sessions" id="http-sessions"><h1>HTTP Sessions</h1></a>
<p>This example demonstrates the HTTP Session support in Ballerina. More session related functions are described in https://ballerinalang.org/docs/api/ under http package.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

service&lt;http&gt; session {

    string key = &quot;status&quot;;
    @http:resourceConfig {
        methods:[&quot;GET&quot;]
    }
    resource sayHello (http:Request req, http:Response res) {
        //createSessionIfAbsent() function returns an existing session for a valid
        //session id, otherwise it returns a new session.
        http:Session session = req.createSessionIfAbsent();
        string result;
        //Session status(new or already existing) is informed by isNew() as boolean
        //value.
        if (session.isNew()) {
            result = &quot;Say hello to a new session&quot;;
        } else {
            result = &quot;Say hello to an existing session&quot;;
        }
        //Binds a string attribute to this session with a key(string).
        session.setAttribute(key, &quot;Session sample&quot;);
        res.setStringPayload(result);
        _ = res.send();
    }

    @http:resourceConfig {
        methods:[&quot;GET&quot;]
    }
    resource doTask (http:Request req, http:Response res) {
        //getSession() returns an existing session for a valid session id. otherwise
        //null.
        http:Session session = req.getSession();
        string attributeValue;
        if (session != null) {
            //Returns the object bound with the specified key.
            attributeValue, _ = (string)session.getAttribute(key);
        } else {
            attributeValue = &quot;Session unavailable&quot;;
        }
        res.setStringPayload(attributeValue);
        _ = res.send();
    }

    @http:resourceConfig {
        methods:[&quot;GET&quot;]
    }
    resource sayBye (http:Request req, http:Response res) {
        http:Session session = req.getSession();
        if (session != null) {
            //Returns session id.
            string id = session.getId();
            //Invalidates this session.
            session.invalidate();
            res.setStringPayload(&quot;Session: &quot; + id + &quot; invalidated&quot;);
        } else {
            res.setStringPayload(&quot;Session unavailable&quot;);
        }
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run http-sessions.bal
ballerina: deploying service(s) in 'http-sessions.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl -v http://localhost:9090/session/sayHello
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Set-Cookie: BSESSIONID=D844B4AAC699........E4E249BE5F21; Path=/session;
&lt; Content-Length: 26

Say hello to a new session

# Copy the BSESSIONID of session cookie in above response.
# Now invoke doTask resource as follows.
$ curl -v http://localhost:9090/session/doTask -H &quot;Cookie: BSESSIONID=..
(use given BSESSIONID)..&quot;
Session sample

# Finally invoke sayBye using same BSESSIONID.
$ curl -v http://localhost:9090/session/sayBye -H &quot;Cookie: BSESSIONID=..
(use same BSESSIONID)..&quot;
Session: ..(same BSESSIONID).. invalidated
</code></pre>
<a class="header" href="print.html#http-client-connector" id="http-client-connector"><h1>HTTP Client Connector</h1></a>
<p>The HTTP Client Connector can be used to connect to and interact with an HTTP server.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;
function main (string[] args) {
    endpoint&lt;http:HttpClient&gt; httpConnector {
        create http:HttpClient(&quot;https://postman-echo.com&quot;, {});
    }
    http:Request req = {};
    //Send a GET request to the specified endpoint
    http:Response resp = {};
    resp, _ = httpConnector.get(&quot;/get?test=123&quot;, req);
    println(&quot;GET request:&quot;);
    println(resp.getJsonPayload());
    //Set a string payload to the message to be sent to the endpoint.
    req.setStringPayload(&quot;POST: Hello World&quot;);
    resp, _ = httpConnector.post(&quot;/post&quot;, req);
    println(&quot;\nPOST request:&quot;);
    println(resp.getJsonPayload());
    //Set a JSON payload to the message to be sent to the endpoint.
    json jsonMsg = {method:&quot;PUT&quot;, payload:&quot;Hello World&quot;};
    req.setJsonPayload(jsonMsg);
    resp, _ = httpConnector.put(&quot;/put&quot;, req);
    println(&quot;\nPUT request:&quot;);
    println(resp.getJsonPayload());
    //Set an XML payload to the message to be sent to the endpoint.
    xml xmlMsg = xml `&lt;request&gt;&lt;method&gt;PATCH&lt;/method&gt;&lt;payload&gt;Hello World!&lt;/payload&gt;
                                            &lt;/request&gt;`;
    req.setXmlPayload(xmlMsg);
    json j = {};
    //Remove the json payload.
    req.setJsonPayload(j);
    resp, _ = httpConnector.patch(&quot;/patch&quot;, req);
    println(&quot;\nPATCH request:&quot;);
    println(resp.getJsonPayload());
    req.setStringPayload(&quot;DELETE: Hello World&quot;);
    resp, _ = httpConnector.delete(&quot;/delete&quot;, req);
    println(&quot;\nDELETE request:&quot;);
    println(resp.getJsonPayload());
    req.setStringPayload(&quot;CUSTOM: Hello World&quot;);
    //The execute() action can be used if one needs to use custom HTTP verbs.
    resp, _ = httpConnector.execute(&quot;COPY&quot;, &quot;/get&quot;, req);
    //The messages and http packages provide various utility functions which are useful
    //when dealing with HTTP requests/responses.
    req = {};
    req.addHeader(&quot;Sample-Name&quot;, &quot;http-client-connector&quot;);
    resp, _ = httpConnector.get(&quot;/get&quot;, req);
    string contentType;
    contentType = resp.getHeader(&quot;Content-Type&quot;);
    println(&quot;\nContent-Type: &quot; + contentType);
    int statusCode = resp.getStatusCode();
    println(&quot;Status code: &quot; + statusCode);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run http-client-connector.bal
GET request:
{&quot;args&quot;:{&quot;test&quot;:&quot;123&quot;},&quot;headers&quot;:{&quot;host&quot;:&quot;postman-echo.com&quot;,&quot;user-agent&quot;
:&quot;ballerina/0.92.1-SNAPSHOT&quot;,&quot;x-forwarded-port&quot;:&quot;443&quot;,&quot;x-forwarded-proto&quot;
:&quot;https&quot;},&quot;url&quot;:&quot;https://postman-echo.com/get?test=123&quot;}

POST request:
{&quot;args&quot;:{},&quot;data&quot;:&quot;POST: Hello World&quot;,&quot;files&quot;:{},&quot;form&quot;:{},&quot;headers&quot;
:{&quot;host&quot;:&quot;postman-echo.com&quot;,&quot;content-length&quot;:&quot;17&quot;,&quot;content-type&quot;:&quot;text/plain&quot;,
&quot;user-agent&quot;:&quot;ballerina/0.92.1-SNAPSHOT&quot;,&quot;x-forwarded-port&quot;:&quot;443&quot;,
&quot;x-forwarded-proto&quot;:&quot;https&quot;},&quot;json&quot;:null,&quot;url&quot;:&quot;https://postman-echo.com/post&quot;}

PUT request:
{&quot;args&quot;:{},&quot;data&quot;:{&quot;method&quot;:&quot;PUT&quot;,&quot;payload&quot;:&quot;Hello World&quot;},&quot;files&quot;:{},
&quot;form&quot;:{},&quot;headers&quot;:{&quot;host&quot;:&quot;postman-echo.com&quot;,&quot;content-length&quot;:&quot;40&quot;,
&quot;content-type&quot;:&quot;application/json&quot;,&quot;user-agent&quot;:&quot;ballerina/0.92.1-SNAPSHOT&quot;,
&quot;x-forwarded-port&quot;:&quot;443&quot;,&quot;x-forwarded-proto&quot;:&quot;https&quot;},&quot;json&quot;:{&quot;method&quot;:&quot;PUT&quot;,
&quot;payload&quot;:&quot;Hello World&quot;},&quot;url&quot;:&quot;https://postman-echo.com/put&quot;}

PATCH request:
{&quot;args&quot;:{},&quot;data&quot;:&quot;&lt;request&gt;&lt;method&gt;PATCH&lt;/method&gt;&lt;payload&gt;Hello World!&lt;/payload&gt;
&lt;/request&gt;&quot;,&quot;files&quot;:{},&quot;form&quot;:{},&quot;headers&quot;:{&quot;host&quot;:&quot;postman-echo.com&quot;,
&quot;content-length&quot;:&quot;72&quot;,&quot;content-type&quot;:&quot;application/xml&quot;,
&quot;user-agent&quot;:&quot;ballerina/0.92.1-SNAPSHOT&quot;,&quot;x-forwarded-port&quot;:&quot;443&quot;,
&quot;x-forwarded-proto&quot;:&quot;https&quot;},&quot;json&quot;:null,&quot;url&quot;:&quot;https://postman-echo.com/patch&quot;}

DELETE request:
{&quot;args&quot;:{},&quot;data&quot;:&quot;DELETE: Hello World&quot;,&quot;files&quot;:{},&quot;form&quot;:{},
&quot;headers&quot;:{&quot;host&quot;:&quot;postman-echo.com&quot;,&quot;content-length&quot;:&quot;19&quot;,&quot;content-type&quot;:&quot;text/plain&quot;,
&quot;user-agent&quot;:&quot;ballerina/0.92.1-SNAPSHOT&quot;,&quot;x-forwarded-port&quot;:&quot;443&quot;,
&quot;x-forwarded-proto&quot;:&quot;https&quot;},&quot;json&quot;:null,&quot;url&quot;:&quot;https://postman-echo.com/delete&quot;}

Content-Type: application/json; charset=utf-8
Status code: 200
</code></pre>
<a class="header" href="print.html#https-server-connector" id="https-server-connector"><h1>HTTPS Server Connector</h1></a>
<p>The HTTP Server Connector can be used to connect to and interact with a HTTP client. Https configurations can be given to server connector to expose a https connection.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

//Ballerina server connector can be used to connect to a https client. If client
//needs to verify server authenticity when establishing the connection, server needs
//to provide keyStoreFile, keyStorePassword and certificate password as given here.
@http:configuration {
    basePath:&quot;/hello&quot;,
    httpsPort:9095,
    keyStoreFile:&quot;${ballerina.home}/bre/security/ballerinaKeystore.p12&quot;,
    keyStorePassword:&quot;ballerina&quot;,
    certPassword:&quot;ballerina&quot;
}

service&lt;http&gt; helloWorld {
    @http:resourceConfig {
        methods:[&quot;GET&quot;],
        path:&quot;/&quot;
    }

    resource sayHello (http:Request req, http:Response res) {
        res.setStringPayload(&quot;Successful&quot;);
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash">#Run the service
$ ballerina run https-server-connector.bal
ballerina: deploying service(s) in 'https-server-connector.bal'
ballerina: started HTTPS/WSS server connector http-9095
</code></pre>
<pre><code class="language-bash">#For the demonstration purpose curl -k command will be used to invoke the service.
$ curl -k https://localhost:9095/hello
Response: Successful
</code></pre>
<a class="header" href="print.html#https-serverclient-connectors" id="https-serverclient-connectors"><h1>HTTPS Server/Client Connectors</h1></a>
<p>This example demonstrates how ballerina https client connector can be configured to connect to a https server through 1-way ssl connection (server is verified by the client). This example uses ballerina https server connector to host a service and https client connector will be sending requests for that server.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

@http:configuration {
    basePath:&quot;/hello&quot;,
    httpsPort:9095,
    keyStoreFile:&quot;${ballerina.home}/bre/security/ballerinaKeystore.p12&quot;,
    keyStorePassword:&quot;ballerina&quot;,
    certPassword:&quot;ballerina&quot;
}

service&lt;http&gt; helloWorld {
    @http:resourceConfig {
        methods:[&quot;GET&quot;],
        path:&quot;/&quot;
    }

    resource sayHello (http:Request req, http:Response res) {
        res.setStringPayload(&quot;Successful&quot;);
        _ = res.send();
    }
}

//Ballerina client connector can be used to connect to the created https server.
//You have to run the service before running this main function. As this is a 1-way
//ssl connection, client needs to provide trustStoreFile and trustStorePassword.
function main (string[] args) {
    endpoint&lt;http:HttpClient&gt; connectorEP {
        create http:HttpClient(&quot;https://localhost:9095&quot;, getConnectorConfigs());
    }
    //Creates a request.
    http:Request req = {};
    http:Response resp = {};
    resp, _ = connectorEP.get(&quot;/hello/&quot;, req);
    println(&quot;Response code: &quot; + resp.getStatusCode());
    println(&quot;Response: &quot; + resp.getStringPayload());
}

function getConnectorConfigs() (http:Options) {
    http:Options option = {
        ssl: {
              trustStoreFile:&quot;${ballerina.home}/bre/security/ballerinaTruststore.p12&quot;,
              trustStorePassword:&quot;ballerina&quot;
             },
          followRedirects: {}
    };
    return option;
}
</code></pre></pre>
<pre><code class="language-bash">#Run the service
$ ballerina run https-server-client-connectors.bal -s
ballerina: deploying service(s) in 'https-server-client-connectors.bal'
ballerina: started HTTPS/WSS server connector http-9095

#Run the main function containing ballerina client
$ ballerina run https-server-client-connectors.bal
Response code: 200
Response: Successful
</code></pre>
<a class="header" href="print.html#http-to-websocket-upgrade" id="http-to-websocket-upgrade"><h1>HTTP to WebSocket Upgrade</h1></a>
<p>This sample explains how a Http endpoint can be updated to a WebSocket endpoint using configuration annotation.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;
import ballerina.net.ws;

@http:configuration {
    basePath:&quot;/hello&quot;,
    webSocket:@http:webSocket {
                  upgradePath:&quot;/ws&quot;,
                  serviceName:&quot;wsService&quot;
              }
}
service&lt;http&gt; httpService {

    @http:resourceConfig {
        path:&quot;/world&quot;,
        methods:[&quot;POST&quot;,&quot;GET&quot;,&quot;PUT&quot;,&quot;My&quot;]
    }
    resource testResource(http:Request req, http:Response resp) {
        string payload = req.getStringPayload();
        println(payload);
        resp.setStringPayload(&quot;I received&quot;);
        _ = resp.send();
    }
}

//Note: When a WebSocket upgrade path is defined in HTTP configuration in WebSocket
//configuration there can be:
//Full service configuration: There will be two base paths for the same service from
//either HTTP or WebSocket
//Without service configuration: WebSocket service will be a slave service of HTTP
//service. Then only the upgrade path can be there.
//Configuration without basePath: It will act as a slave service but can configure sub
//protocols, idle timeout etc...
@ws:configuration {
    basePath:&quot;world/ws&quot;,
    subProtocols:[&quot;xml, json&quot;],
    idleTimeoutInSeconds:5
}
service&lt;ws&gt; wsService  {

    resource onOpen(ws:Connection conn) {
        println(&quot;New WebSocket connection: &quot; + conn.getID());
    }

    resource onTextMessage(ws:Connection conn, ws:TextFrame frame) {
        println(frame.text);
        conn.pushText(frame.text);
    }

    resource onIdleTimeout(ws:Connection conn) {
        println(&quot;Idle timeout: &quot; + conn.getID());
    }
}
</code></pre></pre>
<pre><code class="language-bash"># To run the program, put the code in `http-to-websocket-upgrade.bal`
# and use `ballerina run http-to-websocket-upgrade.bal` command.
$ ballerina run http-to-websocket-upgrade.bal

# To check the sample,use Chrome or Firefox javascript console and run the below commands
# change &quot;xml&quot; to another sub protocol to observe the behavior of WebSocket server.
# There are two endpoints for this WebSocket sample since it is configured that way.
$ var ws = new WebSocket(&quot;ws://localhost:9090/hello/ws&quot;, &quot;xml&quot;, &quot;my-protocol&quot;);
$ var ws = new WebSocket(&quot;ws://localhost:9090/world/ws&quot;, &quot;xml&quot;, &quot;my-protocol&quot;);

$ ws.onmessage = function(frame) {console.log(frame.data)};
$ ws.onclose = function(frame) {console.log(frame)};

# To send messages
$ ws.send(&quot;hello world&quot;);
</code></pre>
<a class="header" href="print.html#log-api" id="log-api"><h1>Log API</h1></a>
<p>The 'ballerina.log' package contains ballerina log handling functions.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.log;

function main(string[] args) {
    error err = {msg: &quot;error occurred&quot;};

    //The Ballerina log API provides functions to log at 5 levels: DEBUG, ERROR,
    //INFO, TRACE and WARN.
    //By default, all log messages are logged to the console at the INFO level.
    //In addition to these log levels, there are 2 additionals levels: OFF and
    //ALL. OFF turns off logging and ALL allows all log levels.
    //Log level can be configured through a Ballerina config file or CLI parameters.

    log:printDebug(&quot;debug log&quot;);
    log:printError(&quot;error log&quot;);
    log:printErrorCause(&quot;error log with cause&quot;, err);
    log:printInfo(&quot;info log&quot;);
    log:printTrace(&quot;trace log&quot;);
    log:printWarn(&quot;warn log&quot;);
    //To set the log level of the API use the CLI parameter: &lt;br&gt;
    //-B[ballerina.log].level=[LOG_LEVEL] &lt;br&gt;

    //To configure using a config file, place the entry given below in the file:
    //[ballerina.log]
    //level=[LOG_LEVEL]
}
</code></pre></pre>
<pre><code class="language-bash"># As it can be seen from the output, only Info and higher level logs are logged
$ ballerina run log-api.bal
2017-11-05 21:20:12,313 ERROR [] - error log
2017-11-05 21:20:12,319 ERROR [] - error log with cause : {msg:&quot;error occurred&quot;, 
cause:null, stackTrace:null}
2017-11-05 21:20:12,320 INFO  [] - info log
2017-11-05 21:20:12,321 WARN  [] - warn log

$ ballerina run log-api.bal -B[ballerina.log].level=TRACE
2017-11-05 21:21:35,394 DEBUG [] - debug log
2017-11-05 21:21:35,400 ERROR [] - error log
2017-11-05 21:21:35,402 ERROR [] - error log with cause : {msg:&quot;error occurred&quot;, 
cause:null, stackTrace:null}
2017-11-05 21:21:35,403 INFO  [] - info log
2017-11-05 21:21:35,403 TRACE [] - trace log
2017-11-05 21:21:35,404 WARN  [] - warn log 
</code></pre>
<a class="header" href="print.html#function-pointers" id="function-pointers"><h1>Function Pointers</h1></a>
<p>A function pointer is a Ballerina type, that allows passing functions as variables, arguments to functions and also as function return values.</p>
<pre><pre class="playpen"><code class="language-ballerina">function test (int x, string s) returns (float f) {
    var y, _ = &lt;int&gt;s;
    f = x * 1.0 * y;
    return;
}

// Function pointer as a parameter.
function foo (int x, function (int, string) returns (float) bar)
             returns (float) {
    return x * bar(10, &quot;2&quot;);
}

// Function pointer as a return type.
function getIt () (function (int, string) returns (float) f) {
    f = test;
    return;
}

function main (string[] args) {
    // Value 'test' will serve as a pointer to 'test' function.
    println(&quot;Answer: &quot; + foo(10, test));
    println(&quot;Answer: &quot; + foo(10, getIt()));
    // Function pointer as a variable;
    function (int, string) returns (float) f = getIt();
    println(&quot;Answer: &quot; + foo(10, f));
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run function-pointers.bal
Answer: 200.0
Answer: 200.0
Answer: 200.0
</code></pre>
<a class="header" href="print.html#lambda" id="lambda"><h1>Lambda</h1></a>
<p>Lambdas are simply a syntactic shortcut for defining a function inline.
In comparison to a normal function definition, the only missing part here is the name. Semantically, these inline anonymous functions will not be allowed to have any references to in-scope variables other than to global or package level variables.</p>
<p>Thus, it behaves exactly like a regular function except that it cannot be called in another place as it has no name.</p>
<pre><pre class="playpen"><code class="language-ballerina">function main (string[] args) {
    // Define lambda function in-line to function pointer var.
    function (string, string) returns (string) lambda =
            function (string x, string y) returns (string r) {
                r = x + y;
                return;
            };
    println(&quot;Output: &quot; + lambda(&quot;Hello &quot;, &quot;world.!!!&quot;));
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run lambda.bal
Output: Hello world.!!!
</code></pre>
<a class="header" href="print.html#websocket-basic-sample" id="websocket-basic-sample"><h1>WebSocket Basic Sample</h1></a>
<p>This program explains the basic functions of WebSocket server endpoint.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.ws;

// This example gives you the basic idea of WebSocket endpoint.
@ws:configuration {
    basePath: &quot;/basic/ws&quot;,
    subProtocols: [&quot;xml&quot;, &quot;json&quot;],
    idleTimeoutInSeconds: 120,
    host: &quot;0.0.0.0&quot;,
    port: 9090,
    wssPort: 9095,
    keyStoreFile: &quot;${ballerina.home}/bre/security/wso2carbon.jks&quot;,
    keyStorePassword: &quot;wso2carbon&quot;,
    certPassword: &quot;wso2carbon&quot;
}
service&lt;ws&gt; SimpleSecureServer {

    string ping = &quot;ping&quot;;
    blob pingData = ping.toBlob(&quot;UTF-8&quot;);

    // This resource is responsible for handling user logic on handshake time.
    // Note that the connection is not yet established while this code is running.
    resource onHandshake(ws:HandshakeConnection conn) {
        println(&quot;\nNew client is going to connect&quot;);
        println(&quot;Connection ID: &quot; + conn.connectionID);
        println(&quot;Is connection secure: &quot; + conn.isSecure);

        println(&quot;pre upgrade headers -&gt; &quot;);
        printHeaders(conn.upgradeHeaders);
    }

    // This resource is triggered after a successful client connection.
    resource onOpen(ws:Connection conn) {
        println(&quot;\nNew client connected&quot;);
        println(&quot;Connection ID: &quot; + conn.getID());
        println(&quot;Negotiated Sub protocol: &quot; + conn.getNegotiatedSubProtocol());
        println(&quot;Is connection open: &quot; + conn.isOpen());
        println(&quot;Is connection secured: &quot; + conn.isSecure());
        println(&quot;Connection header value: &quot; + conn.getUpgradeHeader(&quot;Connection&quot;));
        println(&quot;Upgrade headers -&gt; &quot; );
        printHeaders(conn.getUpgradeHeaders());
    }

    // This resource is triggered when a new text frame is received from a client.
    resource onTextMessage (ws:Connection conn, ws:TextFrame frame) {
        println(&quot;\ntext message: &quot; + frame.text + &quot; &amp; is final fragment: &quot;
                + frame.isFinalFragment);
        string text = frame.text;

        if (text == &quot;ping&quot;) {
            println(&quot;Pinging...&quot;);
            conn.ping(pingData);
        } else if (text == &quot;closeMe&quot;) {
            conn.closeConnection(1001, &quot;You asked me to close connection&quot;);
        } else {
            conn.pushText(&quot;You said: &quot; + frame.text);
        }
    }

    // This resource is triggered when a new binary frame is received from a client.
    resource onBinaryMessage(ws:Connection conn, ws:BinaryFrame frame) {
        println(&quot;\nNew binary message received&quot;);
        blob b = frame.data;
        println(&quot;UTF-8 decoded binary message: &quot; + b.toString(&quot;UTF-8&quot;));
        conn.pushBinary(b);
    }

    // This resource is triggered when a ping message is received from the client.
    resource onPing(ws:Connection conn, ws:PingFrame frame) {
        conn.pong(frame.data);
    }

    // This resource is triggered when a pong message is received.
    resource onPong(ws:Connection conn, ws:PongFrame frame) {
        println(&quot;Pong received&quot;);
    }

    // This resource is triggered when a particular client reaches it's idle timeout
    // defined in the ws:configuration annotation.
    resource onIdleTimeout(ws:Connection conn) {
        // This resource will be triggered after 180 seconds if there is no activity in
        // a given channel.
        println(&quot;\nReached idle timeout&quot;);
        println(&quot;Closing connection &quot; + conn.getID());
        conn.closeConnection(1001, &quot;Connection timeout&quot;);
    }

    // This resource is triggered when a client connection is closed from the client
    // side.
    resource onClose(ws:Connection conn, ws:CloseFrame closeFrame) {
        println(&quot;\nClient left with status code &quot; + closeFrame.statusCode +
                &quot; because &quot; + xcloseFrame.reason);
    }
}

function printHeaders(map headers) {
    string [] headerKeys = headers.keys();
    int len = lengthof headerKeys;
    int i = 0;
    while (i &lt; len) {
        string key = headerKeys[i];
        var value, _ = (string) headers[key];
        println(key + &quot;: &quot; + value);
        i = i + 1;
    }
}
</code></pre></pre>
<pre><code class="language-bash"># To run the program, put the code in `websocket-basic-functions.bal`
# and use `ballerina run websocket-basic-sample.bal` command.
$ ballerina run websocket-basic-sample.bal

# To check the sample,use Chrome or Firefox javascript console and run the below commands
# change &quot;xml&quot; to another sub protocol to observe the behavior of WebSocket server.
$ var ws = new WebSocket(&quot;ws://localhost:9090/basic/ws&quot;, &quot;xml&quot;, &quot;my-protocol&quot;);

$ ws.onmessage = function(frame) {console.log(frame.data)};
$ ws.onclose = function(frame) {console.log(frame)};

# To send messages
$ ws.send(&quot;hello world&quot;);

# Use more advance client to check the ping pong since browser client does not have 
# capability to send pings.
# But to check the the behavior when server sends a ping message to the browser client 
# use the following command
$ ws.send(&quot;ping&quot;);

#To close the connection
$ ws.close(1000, &quot;I want to go&quot;);

# To close connection from server side
$ ws.send(&quot;closeMe&quot;);

# To check the connection closure due to connection timeout wait for 120 seconds
# or change the timeout in configuration annotation

</code></pre>
<a class="header" href="print.html#websocket-chat-application" id="websocket-chat-application"><h1>WebSocket Chat Application</h1></a>
<p>This example explains how to write a simple chat application using Ballerina.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.ws;

@ws:configuration {
    basePath: &quot;/chat/ws&quot;,
    port:9090,
    idleTimeoutInSeconds: 3600
}
service&lt;ws&gt; ChatApp {

    map consMap = {};

    resource onOpen(ws:Connection conn) {
        broadcast(consMap, &quot;New client connected&quot;);
        consMap[conn.getID()] = conn;
    }

    resource onTextMessage(ws:Connection con, ws:TextFrame frame) {
        println(frame.text);
        broadcast(consMap, frame.text);
    }

    resource onIdleTimeout(ws:Connection con) {
        // Connection is closed due to inactivity after 1 hour.
        println(&quot;Idle timeout: &quot; + con.getID());
        con.closeConnection(1000, &quot;Closing connection due to inactivity in chat&quot;);
    }

    resource onClose(ws:Connection con, ws:CloseFrame frame) {
        consMap.remove(con.getID());
        broadcast(consMap, &quot;User left&quot;);
    }
}

function broadcast(map consMap, string text) {
    string[] conKeys = consMap.keys();
    int len = lengthof conKeys;
    int i = 0;
    while (i &lt; len) {
        var con, _ = (ws:Connection) consMap[conKeys[i]];
        con.pushText(text);
        i = i + 1;
    }
}
</code></pre></pre>
<pre><code class="language-bash"># To run the program, put the code in `websocket-chat-application.bal`
# and use `ballerina run websocket-basic-application.bal` command.
$ ballerina run websocket-chat-application.bal

# To check the sample,use Chrome or Firefox javascript console and run the below 
# commands
# Run first 3 lines of the below code in two or more consoles and see how the 
# messages are received by sending messages
$ var ws = new WebSocket(&quot;ws://localhost:9090/chat/ws&quot;);
$ ws.onmessage = function(frame) {console.log(frame.data)};
$ ws.onclose = function(frame) {console.log(frame)};

# To send messages
$ ws.send(&quot;hello world&quot;);

#To close the connection
$ ws.close(1000, &quot;I want to go&quot;);

# To close connection from server side
$ ws.send(&quot;closeMe&quot;);
</code></pre>
<a class="header" href="print.html#websocket-proxy-server" id="websocket-proxy-server"><h1>WebSocket Proxy Server</h1></a>
<p>This example explains how ballerina can act as a simple WebSocket proxy server.
When new client is connected to the WebSocket endpoint, onHandshake new WebSocket client connection is created and stored in a map.</p>
<p>When the endpoint client sends a message, get the client connection for remote server from the map and send the same message to remote server.
That server will echo it back and it will be received to &quot;ClientService&quot; which will print the echoed message.
Then by the client connection from &quot;onTextMessage&quot; resource in &quot;ClientService&quot;, get the parent connection and send it.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.ws;

@ws:configuration {
    basePath: &quot;/proxy/ws&quot;,
    port:9090
}
service&lt;ws&gt; SimpleProxyServer {

    map clientConnMap = {};
    string remoteUrl = &quot;wss://echo.websocket.org&quot;;
    string remoteServerCallbackService = &quot;ClientService&quot;;

    // Create a client connection to remote server from ballerina when new client
    // connects to this service endpoint.
    resource onHandshake(ws:HandshakeConnection con) {
        endpoint&lt;ws:WsClient&gt; c {
            create ws:WsClient(remoteUrl, remoteServerCallbackService);
        }
        var clientConn, err = c.connect({parentConnectionID:con.connectionID});
        if (err != null) {
            println(err.msg);
            con.cancelHandshake(1001, &quot;Cannot connect to remote server&quot;);
        } else {
            clientConnMap[con.connectionID] = clientConn;
        }
    }

    resource onTextMessage(ws:Connection conn, ws:TextFrame frame) {
        var clientCon, _ = (ws:Connection)clientConnMap[conn.getID()];
        clientCon.pushText(frame.text);
    }

    resource onBinaryMessage(ws:Connection conn, ws:BinaryFrame frame) {
        var clientConn, _ = (ws:Connection)clientConnMap[conn.getID()];
        clientConn.pushBinary(frame.data);
    }

    resource onClose(ws:Connection conn, ws:CloseFrame frame) {
        var clientConn, _ = (ws:Connection)clientConnMap[conn.getID()];
        clientConn.closeConnection(frame.statusCode, frame.reason);
        clientConnMap.remove(conn.getID());
    }
}

// Client service to receive frames from remote server
@ws:clientService {}
service&lt;ws&gt; ClientService {

    resource onTextMessage(ws:Connection conn, ws:TextFrame frame) {
        ws:Connection parentConn = conn.getParentConnection();
        parentConn.pushText(frame.text);
    }

    resource onBinaryMessage(ws:Connection conn, ws:BinaryFrame frame) {
        ws:Connection parentConn = conn.getParentConnection();
        parentConn.pushBinary(frame.data);
    }

    resource onClose(ws:Connection conn, ws:CloseFrame frame) {
        ws:Connection parentConn = conn.getParentConnection();
        parentConn.closeConnection(frame.statusCode, frame.reason);
    }

}
</code></pre></pre>
<pre><code class="language-bash"># To run the program, put the code in `websocket-client-connector.bal`
# and use `ballerina run websocket-client-connector` command.
$ ballerina run websocket-proxy-server.bal
# Now that we can run this program using any WebSocket client with 
# &quot;ws://localhost:9090/proxy/ws&quot;

# To check the sample, you can use Chrome or Firefox javascript console 
# and run the below commands &lt;br&gt;
$ var ws = new WebSocket(&quot;ws://localhost:9090/proxy/ws&quot;);
$ ws.onmessage = function(frame) {console.log(frame.data)};
$ ws.onclose = function(frame) {console.log(frame)};

# To send messages
$ ws.send(&quot;hello world&quot;);

#To close the connection
$ ws.close(1000, &quot;I want to go&quot;);
</code></pre>
<a class="header" href="print.html#passthrough" id="passthrough"><h1>Passthrough</h1></a>
<p>The passthrough sample exhibits the process of HTTP client connector. Echo Service is used as a sample backend.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

service&lt;http&gt; passthrough {

    // Requests which contain any HTTP method will be directed to passthrough resource.
    @http:resourceConfig {
        path:&quot;/&quot;
    }
    resource passthrough (http:Request req, http:Response res) {
        endpoint&lt;http:HttpClient&gt; endPoint {
            create http:HttpClient(&quot;http://localhost:9090/echo&quot;, {});
        }
        //Extract HTTP method from the inbound request.
        string method = req.getMethod();
        http:Response clientResponse = {};
        http:HttpConnectorError err;
        //Action execute() does a backend client call and returns the response.
        //It includes endPoint, HTTP method, resource path and request as parameters.
        clientResponse, err = endPoint.execute(method, &quot;/&quot;, req);
        //Native function &quot;forward&quot; sends back the clientResponse to the caller
        //if no any error is found.
        if (err != null) {
            res.setStatusCode(500);
            res.setStringPayload(err.msg);
            _ = res.send();
        } else {
            _ = res.forward(clientResponse);
        }
    }
}

// Sample backend echo service.
service&lt;http&gt; echo {
    // A common resource for POST, PUT and GET methods.
    @http:resourceConfig {
        methods:[&quot;POST&quot;, &quot;PUT&quot;, &quot;GET&quot;],
        path:&quot;/&quot;
    }
    resource echoResource (http:Request req, http:Response res) {
        res.setStringPayload(&quot;Resource is invoked&quot;);
        _ = res.send();
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run passthrough.bal
ballerina: deploying service(s) in 'passthrough.bal'
ballerina: started HTTP/WS server connector 0.0.0.0:9090
</code></pre>
<pre><code class="language-bash">$ curl -v http://localhost:9090/passthrough -X POST
Resource is invoked
$ curl -v http://localhost:9090/passthrough -X GET
Resource is invoked
$ curl -v http://localhost:9090/passthrough -X PUT
Resource is invoked
</code></pre>
<a class="header" href="print.html#mutual-ssl" id="mutual-ssl"><h1>Mutual SSL</h1></a>
<p>Ballerina supports mutual ssl which is a certificate based authentication where two parties (client and server) authenticate each other by verifying digital certificates. So in simple terms both parties are assured of other's identity.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.net.http;

@http:configuration {
    basePath:&quot;/hello&quot;,
    httpsPort:9095,
    keyStoreFile:&quot;${ballerina.home}/bre/security/ballerinaKeystore.p12&quot;,
    keyStorePassword:&quot;ballerina&quot;,
    certPassword:&quot;ballerina&quot;,
    sslVerifyClient:&quot;require&quot;,
    trustStoreFile:&quot;${ballerina.home}/bre/security/ballerinaTruststore.p12&quot;,
    trustStorePassword:&quot;ballerina&quot;,
    ciphers:&quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;,
    sslEnabledProtocols:&quot;TLSv1.2,TLSv1.1&quot;
}

service&lt;http&gt; helloWorld {
    @http:resourceConfig {
        methods:[&quot;GET&quot;],
        path:&quot;/&quot;
    }

    resource sayHello (http:Request req, http:Response res) {
        //Set response payload.
        res.setStringPayload(&quot;Successful&quot;);
        //Send response to client.
        _ = res.send();
    }
}

// Ballerina client connector can be used to connect to the created https server.
//You have to run the service before running this main function. As this is a mutual
//ssl connection, client also needs to provide keyStoreFile, keyStorePassword,
//trustStoreFile and trustStorePassword.
function main (string[] args) {
    endpoint&lt;http:HttpClient&gt; connectorEP {
        create http:HttpClient(&quot;https://localhost:9095&quot;, getConnectorConfigs());
    }
    //Creates a request.
    http:Request req = {};
    http:Response resp = {};
    resp, _ = connectorEP.get(&quot;/hello/&quot;, req);
    println(&quot;Response code: &quot; + resp.getStatusCode());
    println(&quot;Response: &quot; + resp.getStringPayload());
}

function getConnectorConfigs() (http:Options) {
    http:Options option = {
          ssl: {
                 keyStoreFile:&quot;${ballerina.home}/bre/security/ballerinaKeystore.p12&quot;,
                 keyStorePassword:&quot;ballerina&quot;,
                 trustStoreFile:&quot;${ballerina.home}/bre/security/ballerinaTruststore.p12&quot;,
                 trustStorePassword:&quot;ballerina&quot;,
                 ciphers:&quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;,
                 sslEnabledProtocols:&quot;TLSv1.2,TLSv1.1&quot;
               },
          followRedirects: {}
      };
    return option;
}
</code></pre></pre>
<pre><code class="language-bash">#Run the service
$ ballerina run mutual-ssl.bal -s
ballerina: deploying service(s) in 'mutual-ssl.bal'
ballerina: started HTTPS/WSS server connector http-9095

#Run the main function containing ballerina client
$ ballerina run mutual-ssl.bal
Response code: 200
Response: Successful
</code></pre>
<a class="header" href="print.html#caching" id="caching"><h1>Caching</h1></a>
<p>Caching package can be used to cache any user defined values.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.caching;
import ballerina.runtime;

public function main (string[] args) {
    // Create a new cache. Cache cleanup task runs every 5 seconds and clears
    // any expired cache. So cache expiry time is set to 4 seconds demonstrate
    //cache cleaning.
    caching:Cache cache = caching:createCache(&quot;UserCache&quot;, 4000, 10, 0.1);
    // Add a new entry to the cache.
    cache.put(&quot;Name&quot;, &quot;Ballerina&quot;);
    // Get the cached value.
    var name, _ = (string)cache.get(&quot;Name&quot;);
    println(&quot;Name: &quot; + name);
    // Sleep the current thread for 6 seconds.
    runtime:sleepCurrentThread(6000);
    // Since the cache expiry time is 4 seconds, cache cleanup task runs at 5th
    // second cleans the cache while this thread was sleeping. Now this value
    // is empty.
    name, _ = (string)cache.get(&quot;Name&quot;);
    println(&quot;Name: &quot; + name);
}

</code></pre></pre>
<pre><code class="language-bash">$ ballerina run caching.bal
Name: Ballerina
Name:
</code></pre>
<a class="header" href="print.html#byte-io" id="byte-io"><h1>Byte I/O</h1></a>
<p>Will demonstrate how bytes could be read and written through the I/O API.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.file;
import ballerina.io;

// This function will return a ByteChannel from a given file location according
// to the specified file permission whether the file should be opened for
// reading/writing.
function getFileChannel (string filePath, string permission) (io:ByteChannel) {
    //Here's how the path of the file will be specified.
    file:File src = {path:filePath};
    //Here's how the ByteChannel is retrieved from the file.
    io:ByteChannel channel = src.openChannel(permission);
    return channel;
}

// This function will read the specified number of bytes from the given channel.
function readBytes (io:ByteChannel channel, int numberOfBytes) (blob, int) {
    blob bytes;
    int numberOfBytesRead;
    //Here's how the bytes are read from the channel.
    bytes, numberOfBytesRead = channel.readBytes(numberOfBytes);
    return bytes, numberOfBytesRead;
}

// This function will write a byte content with the given offset to a channel.
function writeBytes (io:ByteChannel channel, blob content, int startOffset) (int) {
    //Here's how the bytes are written to the channel.
    int numberOfBytesWritten = channel.writeBytes(content, startOffset);
    return numberOfBytesWritten;
}

// This function will copy all content from source channel to a destination channel.
function copy (io:ByteChannel src, io:ByteChannel dst) {
    //Specifies the number of bytes which should be read from a single read operation.
    int bytesChunk = 10000;
    blob readContent;
    int readCount = -1;
    int numberOfBytesWritten = 0;
    //Here's how we specify to read all the content from
    //source and copy it to the destination.
    while (readCount != 0) {
        readContent, readCount = readBytes(src, bytesChunk);
        numberOfBytesWritten = writeBytes(dst, readContent, 0);
    }
}

function main (string[] args) {
    string srcFilePath = &quot;./files/ballerina.jpg&quot;;
    string dstFilePath = &quot;./files/ballerinaCopy.jpg&quot;;
    io:ByteChannel sourceChannel = getFileChannel(srcFilePath, &quot;r&quot;);
    io:ByteChannel destinationChannel = getFileChannel(dstFilePath, &quot;w&quot;);
    println(&quot;Start to copy files from &quot; + srcFilePath + &quot; to &quot; + dstFilePath);
    copy(sourceChannel, destinationChannel);
    println(&quot;File copy completed. The copied file could be located in &quot; + dstFilePath);
    //Close the created connections.
    sourceChannel.close();
    destinationChannel.close();
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run byte-i-o.bal
Start to copy files from ./files/ballerina.jpg to ./files/ballerinaCopy.jpg
File copy completed. The copied file could be located in ./files/ballerinaCopy.jpg
</code></pre>
<a class="header" href="print.html#character-io" id="character-io"><h1>Character I/O</h1></a>
<p>Will demonstrate how characters could be read and written through I/O APIs.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.file;
import ballerina.io;

// This function will return a CharacterChannel from a given file location according
// to the specified permissions and encoding.
function getFileCharacterChannel (string filePath, string permission, string encoding)
                                 (io:CharacterChannel) {
    file:File src = {path:filePath};
    //First we get the ByteChannel representation of the file.
    io:ByteChannel channel = src.openChannel(permission);
    //Then we convert the byte channel to character channel to read content as text.
    io:CharacterChannel characterChannel = channel.toCharacterChannel(encoding);
    return characterChannel;
}

// This function will read content from a file, append the additional string and
// write content.
function process (io:CharacterChannel sourceChannel,
                  io:CharacterChannel destinationChannel) {
    //Here's the string which will be appended in-between.
    string intermediateCharacterString = &quot; my name is &quot;;
    //First 5 characters in the source file contains the greeting.
    string greetingText = sourceChannel.readCharacters(5);
    //We request for the next set of characters in the file.
    string name = sourceChannel.readCharacters(12);
    //Here's how the greeting is written to the destination file.
    _ = destinationChannel.writeCharacters(greetingText, 0);
    //Here's how the intermediate string is appended to the file.
    _ = destinationChannel.writeCharacters(intermediateCharacterString, 0);
    //Here's how the remaining characters are written to the file, leaving an offset.
    _ = destinationChannel.writeCharacters(name, 1);
}

function main (string[] args) {
    io:CharacterChannel sourceChannel =
    getFileCharacterChannel(&quot;./files/sample.txt&quot;, &quot;r&quot;, &quot;UTF-8&quot;);
    io:CharacterChannel destinationChannel =
    getFileCharacterChannel(&quot;./files/sampleResponse.txt&quot;, &quot;w&quot;, &quot;UTF-8&quot;);
    println(&quot;Started to process the file.&quot;);
    process(sourceChannel, destinationChannel);
    println(&quot;File processing complete.&quot;);
    //Close the created connections.
    sourceChannel.closeCharacterChannel();
    destinationChannel.closeCharacterChannel();
}

</code></pre></pre>
<pre><code class="language-bash">$ ballerina run character-i-o.bal
Started to process the file.
File processing complete.
</code></pre>
<a class="header" href="print.html#record-io" id="record-io"><h1>Record I/O</h1></a>
<p>Will demonstrate how records could be read and written through I/O APIs.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.file;
import ballerina.io;

//This function will return a TextRecordChannel from a given file location.
//The encoding is character represenation of the content in file i.e UTF-8 ASCCI.
//The rs is record seperator i.e newline etc. and fs is field seperator i.e comma etc.
function getFileRecordChannel (string filePath, string permission, string encoding,
                               string rs, string fs) (io:TextRecordChannel) {
    file:File src = {path:filePath};
    //First we get the ByteChannel representation of the file.
    io:ByteChannel channel = src.openChannel(permission);
    //Then we convert the byte channel to character channel to read content as text.
    io:CharacterChannel characterChannel = channel.toCharacterChannel(encoding);
    //Finally we convert the character channel to record channel
    //to read content as records.
    io:TextRecordChannel textRecordChannel = characterChannel.
                                             toTextRecordChannel(rs, fs);
    return textRecordChannel;
}

//This function will process CSV file and write content back as text with '|' delimiter
function process (io:TextRecordChannel srcRecordChannel,
                  io:TextRecordChannel dstRecordChannel) {
    int numberOfFields = -1;
    //We read all the records from the provided file until there're no records returned
    while (numberOfFields != 0) {
        //Here's how we read records.
        string[] records = srcRecordChannel.readTextRecord();
        //Here's how we write records.
        dstRecordChannel.writeTextRecord(records);
        numberOfFields = lengthof records;
    }
}

function main (string[] args) {
    string srcFileName = &quot;./files/sample.csv&quot;;
    string dstFileName = &quot;./files/sampleResponse.txt&quot;;
    //Here we specify the location of the CSV file where the record separator is
    //new line and field separator is comma.
    io:TextRecordChannel srcRecordChannel =
    getFileRecordChannel(srcFileName, &quot;r&quot;, &quot;UTF-8&quot;, &quot;\\r?\\n&quot;, &quot;,&quot;);
    //Here we specify the location of the text file where the record separator
    //is new line and field separator is pipe.
    io:TextRecordChannel dstRecordChannel =
    getFileRecordChannel(dstFileName, &quot;w&quot;, &quot;UTF-8&quot;, &quot;\n&quot;, &quot;|&quot;);
    println(&quot;Start to process CSV file from &quot; + srcFileName + &quot; to text file in &quot;
            + dstFileName);
    process(srcRecordChannel, dstRecordChannel);
    println(&quot;Processing completed. The processed file could be located in &quot;
            + dstFileName);
    //Close the text record channel.
    srcRecordChannel.closeTextRecordChannel();
    dstRecordChannel.closeTextRecordChannel();
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run record-i-o.bal
Start to process CSV file from ./files/sample.csv to text file in 
./files/sampleResponse.txt
Processing completed. The processed file could be located in ./files/sampleResponse.txt
</code></pre>
<a class="header" href="print.html#math-functions" id="math-functions"><h1>Math Functions</h1></a>
<p>Ballerina Math API contains methods to help you perform various numerical operations.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.math;

function main (string[] args) {

    println(&quot;Value of PI : &quot; + math:PI );
    println(&quot;Value of E  : &quot; + math:E );
  
    //Returns the absolute value of a float value.
    float absoluteFloatValue = math:absFloat(-152.2544);
    println(&quot;Absolute value of -152.2544 : &quot; + absoluteFloatValue );

    //Returns the absolute value of an int value.
    int absoluteIntValue = math:absInt(-152);
    println(&quot;Absolute value of -152      : &quot; + absoluteIntValue );
    
    //Returns the arc cosine of a value.
    float acosValue = math:acos(0.027415567780803774);
    println(&quot;Arc cosine of 0.027415567780803774  : &quot; + acosValue);

    //Returns the arc sine of a value.
    float arcSineValue = math:asin(0.027415567780803774);
    println(&quot;Arc sine of 0.027415567780803774    : &quot; + arcSineValue);

    //Returns the arc tangent of a value.
    float arcTangent = math:atan(0.027415567780803774);
    println(&quot;Arc tangent of 0.027415567780803774 : &quot; + arcTangent);

    //Returns the cube root of a float value.
    float cubeRoot = math:cbrt(-27);
    println(&quot;Cube root of 0.027415567780803774   : &quot; + cubeRoot);

    //There are altogether 40+ methods in ballerina math API to perform numeric
    //operations and you can find them in &quot;ballerina.math&quot; package.
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run math-functions.bal
Value of PI : 3.141592653589793
Value of E  : 2.718281828459045
Absolute value of -152.2544 : 152.2544
Absolute value of -152      : 152
Arc cosine of 0.027415567780803774  : 1.5433773235341761
Arc sine of 0.027415567780803774    : 0.02741900326072046
Arc tangent of 0.027415567780803774 : 0.0274087022410345
Cube root of 0.027415567780803774   : -3.0
</code></pre>
<a class="header" href="print.html#task-timer" id="task-timer"><h1>Task Timer</h1></a>
<p>Timers are used to execute tasks periodically. A timer may have an initial delay &amp; interval specified.
The delay specifies the delay between registering the task and its first execution. Thereafter, the timer will  go off at regular intervals. A trigger function is called when the timer goes off. If a failure occurs during the execution of the trigger function, it will return an error. That error will be passed to the onError function.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.task;
import ballerina.math;

int count;

function main (string[] args) {
    println(&quot;Timer task demo&quot;);

    // the cleanup function will be called every time the timer goes off.
    function () returns (error) onTriggerFunction = cleanup;

    // the cleanup error function will be called if an error occurs while cleaning up.
    function (error e) onErrorFunction = cleanupError;

    // Schedule a timer task which initially runs 500ms from now and there
    //onwards runs every 1000ms.
    var taskId, schedulerError = task:scheduleTimer(onTriggerFunction,
                                         onErrorFunction, {delay:500, interval:1000});
    if (schedulerError != null) {
        println(&quot;Timer scheduling failed: &quot; + schedulerError.msg) ;
    } else {
        println(&quot;Task ID:&quot; + taskId);
    }
}

function cleanup() returns (error e) {
    count = count + 1;
    println(&quot;Cleaning up...&quot;);
    println(count);

    // We randomly return an error to demonstrate how the error is propagated to the
     //onError function when an error occurs in the onTrigger function.
    if(math:randomInRange(0,10) == 5) {
        e = {msg:&quot;Cleanup error&quot;};
    }
    return;
}

function cleanupError(error e) {
    print(&quot;[ERROR] cleanup failed&quot;);
    println(e);
}
</code></pre></pre>
<pre><code class="language-bash">$ ballerina run task-timer.bal
Timer task demo
Task ID:ff6c2d4f-d9c2-46f4-a176-306d31fd2830
Cleaning up...
1
Cleaning up...
2
Cleaning up...
3
Cleaning up...
4
...
...
</code></pre>
<a class="header" href="print.html#task-appointment" id="task-appointment"><h1>Task Appointment</h1></a>
<p>An appointment is a task that is executed on clock time. Cron syntax is used to define the time, and in case of recurring appointments, the frequency of the appointment.</p>
<p>A trigger function is called when an appointment is due. If a failure occurs during the execution of the trigger function, it will return an error. That error will be passed to the onError function.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.task;
import ballerina.math;
import ballerina.log;

int app1Count;
string app1Tid;

function main (string[] args) {
    worker w1 {
        log:printInfo(&quot;------- Scheduling Appointments ----------------&quot;);

        function () returns (error) onTriggerFunction;
        function (error e) onErrorFunction;

        // job 1 will run every 20 seconds
        onTriggerFunction = appointment1Cleanup;
        onErrorFunction = cleanupError;
        app1Tid, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0/20 * * * * ?&quot;);

        // job 2 will run every other minute (at 15 seconds past the minute)
        onTriggerFunction = appointment2Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;15 0/2 * * * ?&quot;);

        // job 3 will run every other minute but only between 8am and 5pm.
        onTriggerFunction = appointment3Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0 0/2 8-17 * * ?&quot;);

        // job 4 will run every three minutes but only between 5pm and 11pm.
        onTriggerFunction = appointment4Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0 0/3 17-23 * * ?&quot;);

        // job 5 will run at 10am on the 1st and 15th days of the month.
        onTriggerFunction = appointment5Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0 0 10am 1,15 * ?&quot;);

        // job 6 will run every 30 seconds but only on Weekdays.(Monday through Friday)
        onTriggerFunction = appointment6Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0,30 * * ? * MON-FRI&quot;);

        // job 7 will run every 30 seconds but only on Weekends.(Saturday and Sunday)
        onTriggerFunction = appointment7Cleanup;
        onErrorFunction = cleanupError;
        _, _ = task:scheduleAppointment(onTriggerFunction, onErrorFunction,
                                        &quot;0,30 * * ? * SAT,SUN&quot;);
    }
}

function appointment1Cleanup() returns (error) {
    log:printInfo(&quot;Appointment#1 cleanup running...&quot;);
    app1Count = app1Count + 1;
    if(app1Count == 5) {
        log:printInfo(&quot;Stopping Appointment#1 cleanup task since it has run 5 times&quot;);
        // This is how you stop a task.
        _ = task:stopTask(app1Tid);
    }
    return cleanup();
}

function appointment2Cleanup() returns (error){
    log:printInfo(&quot;Appointment#2 cleanup running...&quot;);
    return cleanup();
}

function appointment3Cleanup() returns (error){
    log:printInfo(&quot;Appointment#3 cleanup running...&quot;);
    return cleanup();
}

function appointment4Cleanup() returns (error){
    log:printInfo(&quot;Appointment#4 cleanup running...&quot;);
    return cleanup();
}

function appointment5Cleanup() returns (error){
    log:printInfo(&quot;Appointment#5 cleanup running...&quot;);
    return cleanup();
}

function appointment6Cleanup() returns (error){
    log:printInfo(&quot;Appointment#6 cleanup running...&quot;);
    return cleanup();
}

function appointment7Cleanup() returns (error){
    log:printInfo(&quot;Appointment#7 cleanup running...&quot;);
    return cleanup();
}

function cleanup() returns (error e) {
    log:printInfo(&quot;Cleaning up&quot;);
    if(math:randomInRange(0, 10) == 5) {
        e = {msg:&quot;Cleanup error&quot;};
    }
    return;
}

function cleanupError(error e) {
    log:printErrorCause(&quot;[ERROR] cleanup failed&quot;, e);
}

</code></pre></pre>
<pre><code class="language-bash">$ ballerina run task-appointment.bal
</code></pre>
<a class="header" href="print.html#config-api" id="config-api"><h1>Config API</h1></a>
<p>The 'ballerina.config' package provides an API for reading configurations from various sources such as files, env variables and CLI params.</p>
<pre><pre class="playpen"><code class="language-ballerina">import ballerina.config;

function main(string[] args) {
    // Ballerina config API provides a mechanism for developers to look-up values
    // from config files, CLI parameters, environment variables etc.
    // The precedence order for config lookup is as follows:
    // * CLI parameters
    // * Environment variables
    // * Config file
    // If a particular config defined in the file is also defined as an environment
    // variable, the env variable takes precedence.
    // Similarly, if the same is set as a CLI param it replaces the env variable value.
    // The configs are simply arbitrary key/value pairs with slight structure to it.
    string[] users = config:getGlobalValue(&quot;username.instances&quot;).split(&quot;,&quot;);
    string user1Rights = config:getInstanceValue(users[0], &quot;access.rights&quot;);
    string user2Rights = config:getInstanceValue(users[1], &quot;access.rights&quot;);

    println(users[0] + &quot; has &quot; + user1Rights + &quot; access&quot;);
    println(users[1] + &quot; has &quot; + user2Rights + &quot; access&quot;);
    // A sample config file looks as follows:
    // username.instances=john,peter
    // [john]
    // access.rights=RW
    // [peter]
    // access.rights=R
    // The same configs can be set using CLI params as follows:
    // -Busername.instances=john,peter -B[john].access.rights=RW
    // -B[peter].access.rights=R
}
</code></pre></pre>
<pre><code class="language-bash"># To explicitly specify the config file, one can use the -Bballerina.conf flag as shown.
# If this is not set, Ballerina will look for a &quot;ballerina.conf&quot; file in the directory 
# from which the user executes the program. 
# The path to the config file can either be an absolute path or a relative path.
$ ballerina run config-api.bal -Bballerina.conf=path/to/conf/file/custom-config-
  file-name.conf
john has RW access
peter has R access

# The same configs given through a config file can also be given through CLI params 
# as shown.
# Notice how the instance config keys are prefixed with the instance tag.
# i.e: [john].access.rights
$ ballerina run config-api.bal -Busername.instances=john,peter -B[john].access.rights=RW 
  -B[peter].access.rights=R
john has RW access
peter has R access
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
            // START - Ballerina-By-Example customization
            $("#edit-button").click(function(){
                var editWindow = window.open("https://github.com/NatashaWso2/examples/edit/master/ballerina-by-example/" +
                        "src/print.md");
            });
            // END - Ballerina-By-Example customization
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
